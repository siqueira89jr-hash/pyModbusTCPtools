{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"In\u00edcio","text":""},{"location":"#pymodbustcptools","title":"pyModbusTCPtools","text":"<p>pyModbusTCPtools \u00e9 uma biblioteca Python focada em comunica\u00e7\u00e3o Modbus TCP resiliente, projetada para uso em ambientes industriais reais, onde instabilidade de rede, reconex\u00f5es autom\u00e1ticas e convers\u00f5es de dados confi\u00e1veis s\u00e3o requisitos b\u00e1sicos.</p> <p>A biblioteca adiciona uma camada robusta sobre o protocolo Modbus TCP tradicional, oferecendo:</p> <ul> <li>Leitura e escrita tipada (INT, UINT, FLOAT, DOUBLE)</li> <li>Suporte avan\u00e7ado a endianness e word/byte swap</li> <li>Opera\u00e7\u00f5es seguras com reconex\u00e3o autom\u00e1tica</li> <li>Tratamento consistente de exce\u00e7\u00f5es</li> <li>Cache inteligente de endere\u00e7os inv\u00e1lidos</li> <li>API clara, expl\u00edcita e orientada \u00e0 produ\u00e7\u00e3o</li> </ul>"},{"location":"#objetivo-da-biblioteca","title":"Objetivo da biblioteca","text":"<p>O objetivo do pyModbusTCPtools \u00e9 fornecer uma API confi\u00e1vel e reutiliz\u00e1vel para comunica\u00e7\u00e3o Modbus TCP em Python, evitando c\u00f3digo repetitivo, fr\u00e1gil e dif\u00edcil de manter, comum em aplica\u00e7\u00f5es industriais.</p> <p>Ela foi projetada para ser utilizada em:</p> <ul> <li>Supervis\u00f3rios web (Streamlit, Flask, FastAPI)</li> <li>Sistemas embarcados (Raspberry Pi)</li> <li>Gateways industriais</li> <li>Servi\u00e7os de coleta de dados</li> <li>Integra\u00e7\u00f5es OT/IT</li> <li>Scripts de controle, monitoramento e diagn\u00f3stico</li> </ul>"},{"location":"#principios-de-projeto","title":"Princ\u00edpios de projeto","text":"<p>A biblioteca segue princ\u00edpios t\u00e9cnicos claros:</p> <ul> <li>Fail-safe: falhas de comunica\u00e7\u00e3o s\u00e3o tratadas explicitamente</li> <li>Reconex\u00e3o autom\u00e1tica com backoff exponencial</li> <li>API expl\u00edcita e previs\u00edvel</li> <li>Nenhuma opera\u00e7\u00e3o silenciosa ou impl\u00edcita</li> <li>Foco em estabilidade e compatibilidade de API</li> <li>Projeto orientado a uso industrial real</li> </ul>"},{"location":"#o-que-a-biblioteca-nao-e","title":"O que a biblioteca n\u00e3o \u00e9","text":"<p>Para evitar interpreta\u00e7\u00f5es incorretas, o pyModbusTCPtools n\u00e3o \u00e9:</p> <ul> <li>Uma API REST</li> <li>Um servidor Modbus</li> <li>Um sistema SCADA</li> <li>Uma abstra\u00e7\u00e3o gen\u00e9rica de CLPs</li> <li>Um substituto de plataformas SCADA comerciais</li> </ul> <p>Trata-se de uma biblioteca cliente Modbus TCP, voltada exclusivamente \u00e0 comunica\u00e7\u00e3o, convers\u00e3o e confiabilidade de dados.</p>"},{"location":"#funcionalidades-principais","title":"Funcionalidades principais","text":""},{"location":"#comunicacao-modbus-tcp","title":"Comunica\u00e7\u00e3o Modbus TCP","text":"<ul> <li>Coils</li> <li>Discrete Inputs</li> <li>Input Registers</li> <li>Holding Registers</li> </ul>"},{"location":"#leitura-e-escrita-tipada","title":"Leitura e escrita tipada","text":"<ul> <li>INT16 / UINT16</li> <li>INT32 / UINT32</li> <li>INT64 / UINT64</li> <li>FLOAT32</li> <li>FLOAT64 (DOUBLE)</li> </ul>"},{"location":"#endianness-suportado","title":"Endianness suportado","text":"<ul> <li>Big Endian (padr\u00e3o Modbus)</li> <li>Little Endian (word swap)</li> <li>Big Endian com byte swap</li> <li>Little Endian com byte swap</li> </ul>"},{"location":"#robustez-operacional","title":"Robustez operacional","text":"<ul> <li>Reconex\u00e3o autom\u00e1tica</li> <li>Backoff exponencial configur\u00e1vel</li> <li>Verifica\u00e7\u00e3o ativa de conex\u00e3o</li> <li>Cache de endere\u00e7os inv\u00e1lidos (Illegal Data Address)</li> <li>Logging estruturado</li> </ul>"},{"location":"#estrutura-da-api","title":"Estrutura da API","text":"<p>O n\u00facleo da biblioteca \u00e9 a classe:</p> <p>ModbusTCPResiliente</p> <p>Ela fornece m\u00e9todos expl\u00edcitos para:</p> <ul> <li>Leitura segura (m\u00e9todos com sufixo _safe)</li> <li>Escrita segura (m\u00e9todos com sufixo _safe)</li> <li>Leitura tipada de registradores</li> <li>Escrita tipada de registradores</li> <li>Convers\u00e3o autom\u00e1tica de dados Modbus</li> </ul> <p>Os comportamentos de endianness e tipos s\u00e3o controlados por enums:</p> <ul> <li>Endian</li> <li>ModbusDataType</li> </ul> <p>As exce\u00e7\u00f5es espec\u00edficas permitem distinguir claramente:</p> <ul> <li>Erros de conex\u00e3o</li> <li>Erros de protocolo Modbus</li> <li>Erros de leitura e escrita</li> <li>Erros de convers\u00e3o de dados</li> </ul>"},{"location":"#exemplo-rapido","title":"Exemplo r\u00e1pido","text":"<pre><code>from pyModbusTCPtools import ModbusTCPResiliente, Endian, ModbusDataType\n\nclient = ModbusTCPResiliente(\n    host=\"192.168.0.10\",\n    unit_id=1,\n    timeout=3.0,\n    console=True\n)\n\ntemperatura = client.read_holding_typed_safe(\n    addr=100,\n    dtype=ModbusDataType.FLOAT32,\n    endian=Endian.BE\n)\n\nif temperatura is not None:\n    print(f\"Temperatura: {temperatura:.2f} \u00b0C\")\n</code></pre>"},{"location":"#instalacao","title":"Instala\u00e7\u00e3o","text":""},{"location":"#instalacao-via-pip","title":"Instala\u00e7\u00e3o via pip:","text":"<pre><code>pip install pyModbusTCPtools\n</code></pre>"},{"location":"#instalacao-local-a-partir-de-pacote-wheel","title":"Instala\u00e7\u00e3o local a partir de pacote wheel:","text":"<pre><code>pip install pyModbusTCPtools-0.1.0-py3-none-any.whl\n</code></pre>"},{"location":"#proximos-passos-na-documentacao","title":"Pr\u00f3ximos passos na documenta\u00e7\u00e3o","text":"<p>A leitura recomendada da documenta\u00e7\u00e3o segue a seguinte ordem:</p> <ol> <li>Instala\u00e7\u00e3o</li> <li>Quickstart</li> <li>Conceitos (Modbus, endianness e tratamento de erros)</li> <li>API (documenta\u00e7\u00e3o da classe p\u00fablica)</li> <li>Exemplos de uso</li> </ol>"},{"location":"#roadmap","title":"Roadmap","text":"<ul> <li>Consolida\u00e7\u00e3o da API p\u00fablica</li> <li>Expans\u00e3o de exemplos industriais</li> <li>Amplia\u00e7\u00e3o da cobertura de testes</li> <li>Lan\u00e7amento da vers\u00e3o 1.0.0 est\u00e1vel</li> </ul>"},{"location":"#licenca","title":"Licen\u00e7a","text":"<p>Este projeto \u00e9 distribu\u00eddo sob a licen\u00e7a MIT, permitindo uso comercial e industrial sem restri\u00e7\u00f5es.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":"<p>Todas as mudan\u00e7as relevantes do projeto pyModbusTCPtools ser\u00e3o documentadas neste arquivo.</p> <p>Este projeto segue as boas pr\u00e1ticas de versionamento sem\u00e2ntico (Semantic Versioning \u2013 SemVer):</p> <ul> <li><code>MAJOR</code>: mudan\u00e7as incompat\u00edveis na API</li> <li><code>MINOR</code>: adi\u00e7\u00e3o de funcionalidades compat\u00edveis</li> <li><code>PATCH</code>: corre\u00e7\u00f5es de bugs e ajustes internos</li> </ul>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#planejado","title":"Planejado","text":"<ul> <li>Consolida\u00e7\u00e3o final da API p\u00fablica</li> <li>Revis\u00e3o completa de testes automatizados</li> <li>Otimiza\u00e7\u00f5es internas de robustez</li> <li>Prepara\u00e7\u00e3o para release est\u00e1vel 1.0.0</li> </ul>"},{"location":"changelog/#010-2026-01-18","title":"[0.1.0] \u2013 2026-01-18","text":""},{"location":"changelog/#adicionado","title":"Adicionado","text":"<ul> <li>Classe <code>ModbusTCPResiliente</code> como cliente Modbus TCP principal</li> <li>Leitura segura de Coils (<code>read_coils_safe</code>)</li> <li>Escrita segura de Coils (<code>write_single_coil_safe</code>, <code>write_multiple_coils_safe</code>)</li> <li>Leitura de Discrete Inputs (<code>read_discrete_inputs_safe</code>)</li> <li>Leitura de Holding Registers (bruto)</li> <li>Escrita de Holding Registers (bruto)</li> <li>Leitura tipada de registradores:</li> <li>INT16 / UINT16</li> <li>INT32 / UINT32</li> <li>INT64 / UINT64</li> <li>FLOAT32</li> <li>FLOAT64</li> <li>Escrita tipada de registradores:</li> <li>INT16 / UINT16</li> <li>INT32 / UINT32</li> <li>INT64 / UINT64</li> <li>FLOAT32</li> <li>FLOAT64</li> <li>Suporte completo a endianness:</li> <li>Big Endian</li> <li>Little Endian (word swap)</li> <li>Byte swap</li> <li>Word + byte swap</li> <li>Reconex\u00e3o autom\u00e1tica com backoff exponencial</li> <li>Cache interno de endere\u00e7os Modbus inv\u00e1lidos</li> <li>Logging estruturado com op\u00e7\u00e3o de console e arquivo</li> <li>Enums p\u00fablicos:</li> <li><code>Endian</code></li> <li><code>ModbusDataType</code></li> <li>Exce\u00e7\u00f5es espec\u00edficas:</li> <li><code>ModbusConnectionError</code></li> <li><code>ModbusProtocolError</code></li> <li><code>ModbusReadError</code></li> <li><code>ModbusWriteError</code></li> <li><code>ModbusConversionError</code></li> </ul>"},{"location":"changelog/#documentacao","title":"Documenta\u00e7\u00e3o","text":"<ul> <li>Documenta\u00e7\u00e3o completa com MkDocs + Material</li> <li>Se\u00e7\u00e3o de conceitos:</li> <li>Fundamentos do Modbus</li> <li>Endianness</li> <li>Tratamento de erros</li> <li>Documenta\u00e7\u00e3o da API:</li> <li>Client</li> <li>Enums</li> <li>Exceptions</li> <li>Exemplos pr\u00e1ticos:</li> <li>Leitura e escrita de Coils</li> <li>Discrete Inputs</li> <li>Leitura e escrita de INT16 / INT32 / INT64</li> <li>Leitura e escrita de FLOAT32 / FLOAT64</li> <li>Reconex\u00e3o autom\u00e1tica</li> </ul>"},{"location":"changelog/#infraestrutura","title":"Infraestrutura","text":"<ul> <li>Estrutura de projeto compat\u00edvel com PyPI</li> <li>Suporte a Python 3.8+</li> <li>Licen\u00e7a MIT</li> </ul>"},{"location":"changelog/#notas","title":"Notas","text":"<ul> <li>A vers\u00e3o <code>0.1.0</code> \u00e9 considerada funcional, por\u00e9m ainda em evolu\u00e7\u00e3o</li> <li>Mudan\u00e7as de API podem ocorrer at\u00e9 a vers\u00e3o <code>1.0.0</code></li> <li>Recomenda-se fixar vers\u00e3o em ambientes de produ\u00e7\u00e3o</li> </ul>"},{"location":"changelog/#links","title":"Links","text":"<ul> <li>Reposit\u00f3rio: https://github.com/siqueira89jr-hash/pyModbusTCPtools</li> <li>Documenta\u00e7\u00e3o: https://siqueira89jr-hash.github.io/pyModbusTCPtools</li> </ul>"},{"location":"installation/","title":"Instala\u00e7\u00e3o","text":""},{"location":"installation/#instalacao","title":"Instala\u00e7\u00e3o","text":"<p>Esta se\u00e7\u00e3o descreve os m\u00e9todos suportados para instala\u00e7\u00e3o da biblioteca pyModbusTCPtools em ambientes de desenvolvimento e produ\u00e7\u00e3o.</p> <p>A biblioteca foi projetada para funcionar com Python moderno (&gt;= 3.8) e \u00e9 compat\u00edvel com ambientes industriais como servidores Linux, Raspberry Pi e sistemas Windows.</p>"},{"location":"installation/#requisitos","title":"Requisitos","text":"<p>Antes de instalar, verifique se o ambiente atende aos seguintes requisitos:</p> <ul> <li>Python 3.8 ou superior</li> <li>Acesso \u00e0 rede onde o dispositivo Modbus TCP est\u00e1 conectado</li> <li>Permiss\u00e3o para instalar pacotes Python no ambiente (virtual ou sistema)</li> </ul>"},{"location":"installation/#instalacao-via-pip-recomendada","title":"Instala\u00e7\u00e3o via pip (recomendada)","text":"<p>Este \u00e9 o m\u00e9todo recomendado para a maioria dos usu\u00e1rios.</p> <pre><code>pip install pyModbusTCPtools\n</code></pre> <p>Esse comando instala automaticamente a vers\u00e3o mais recente dispon\u00edvel no PyPI, juntamente com suas depend\u00eancias.</p>"},{"location":"installation/#instalacao-em-ambiente-virtual-venv","title":"Instala\u00e7\u00e3o em ambiente virtual (venv)","text":"<p>Para projetos profissionais e ambientes de produ\u00e7\u00e3o, recomenda-se o uso de um ambiente virtual Python.</p> <p>Criar ambiente virtual</p> <pre><code>python -m venv .venv\n</code></pre> <p>Ativar o ambiente virtual</p> <p>Linux / macOS:</p> <pre><code>source .venv/bin/activate\n</code></pre> <p>Windows (PowerShell):</p> <pre><code>.venv\\Scripts\\Activate.ps1\n</code></pre> <p>Instalar a biblioteca no ambiente virtual</p> <pre><code>pip install pyModbusTCPtools\n</code></pre>"},{"location":"installation/#instalacao-local-a-partir-de-um-pacote-wheel","title":"Instala\u00e7\u00e3o local a partir de um pacote wheel","text":"<p>Este m\u00e9todo \u00e9 \u00fatil em ambientes industriais sem acesso direto \u00e0 internet ou com controle r\u00edgido de vers\u00f5es.</p> <pre><code>pip install pyModbusTCPtools-0.1.0-py3-none-any.whl\n</code></pre> <p>O arquivo .whl deve estar presente no diret\u00f3rio atual ou o caminho completo deve ser informado.</p>"},{"location":"installation/#dependencias","title":"Depend\u00eancias","text":"<p>A biblioteca utiliza internamente o pacote:</p> <ul> <li>pyModbusTCP &gt;= 0.2.0</li> </ul> <p>Essa depend\u00eancia \u00e9 instalada automaticamente quando a biblioteca \u00e9 instalada via pip ou wheel.</p>"},{"location":"installation/#verificacao-da-instalacao","title":"Verifica\u00e7\u00e3o da instala\u00e7\u00e3o","text":"<p>Ap\u00f3s a instala\u00e7\u00e3o, \u00e9 poss\u00edvel validar rapidamente se a biblioteca est\u00e1 dispon\u00edvel no ambiente:</p> <pre><code>python -c \"from pyModbusTCPtools import ModbusTCPResiliente; print('OK')\"\n</code></pre> <p>Se n\u00e3o houver erros, a instala\u00e7\u00e3o foi conclu\u00edda com sucesso.</p> <p>Observa\u00e7\u00f5es para ambientes industriais:</p> <ul> <li>Recomenda-se fixar a vers\u00e3o da biblioteca em produ\u00e7\u00e3o</li> <li>Utilize ambientes virtuais sempre que poss\u00edvel</li> <li>Em sistemas embarcados, evite atualizar depend\u00eancias sem valida\u00e7\u00e3o pr\u00e9via</li> <li>Para deploys offline, prefira o uso de arquivos wheel versionados</li> </ul>"},{"location":"installation/#proximo-passo","title":"Pr\u00f3ximo passo","text":"<p>Ap\u00f3s a instala\u00e7\u00e3o, siga para o Quickstart para criar a primeira conex\u00e3o Modbus TCP e realizar leituras e escritas b\u00e1sicas.</p>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#quickstart","title":"Quickstart","text":"<p>Este guia apresenta um primeiro contato pr\u00e1tico com a biblioteca pyModbusTCPtools, mostrando como estabelecer conex\u00e3o, ler e escrever dados Modbus TCP de forma segura e tipada.</p> <p>O objetivo \u00e9 permitir que a biblioteca seja utilizada em poucos minutos, com foco em uso industrial real e sem abstra\u00e7\u00f5es desnecess\u00e1rias.</p>"},{"location":"quickstart/#pre-requisitos","title":"Pr\u00e9-requisitos","text":"<ul> <li>Python 3.8 ou superior</li> <li>Acesso a um dispositivo Modbus TCP (CLP, gateway ou simulador)</li> <li>Biblioteca pyModbusTCPtools instalada</li> </ul>"},{"location":"quickstart/#instalacao","title":"Instala\u00e7\u00e3o","text":""},{"location":"quickstart/#instalacao-via-pip","title":"Instala\u00e7\u00e3o via pip:","text":"<pre><code>pip install pyModbusTCPtools\n</code></pre>"},{"location":"quickstart/#instalacao-local-a-partir-de-um-pacote-wheel","title":"Instala\u00e7\u00e3o local a partir de um pacote wheel:","text":"<pre><code>pip install pyModbusTCPtools-0.1.0-py3-none-any.whl\n</code></pre>"},{"location":"quickstart/#importacoes-basicas","title":"Importa\u00e7\u00f5es b\u00e1sicas","text":"<pre><code>from pyModbusTCPtools import (\n    ModbusTCPResiliente,\n    Endian,\n    ModbusDataType\n)\n</code></pre>"},{"location":"quickstart/#criando-o-cliente-modbus-tcp","title":"Criando o cliente Modbus TCP","text":"<p>O n\u00facleo da biblioteca \u00e9 a classe ModbusTCPResiliente.</p> <p>Exemplo de cria\u00e7\u00e3o do cliente: </p><pre><code>client = ModbusTCPResiliente(\n    host=\"192.168.0.10\",\n    port=502,\n    unit_id=1,\n    timeout=3.0,\n    retry_delay=2.0,\n    max_retry_delay=30.0,\n    console=True\n)\n</code></pre> Descri\u00e7\u00e3o dos principais par\u00e2metros:<p></p> <ul> <li>host: endere\u00e7o IP do dispositivo Modbus</li> <li>port: porta TCP (padr\u00e3o 502)</li> <li>unit_id: identificador do escravo Modbus</li> <li>timeout: tempo m\u00e1ximo de espera por resposta</li> <li>retry_delay: atraso inicial entre tentativas de reconex\u00e3o</li> <li>max_retry_delay: limite m\u00e1ximo do backoff exponencial</li> <li>console: habilita sa\u00edda de logs no console</li> </ul>"},{"location":"quickstart/#leitura-de-coils","title":"Leitura de Coils","text":"<p>Leitura segura de coils (valores booleanos): </p><pre><code>result = client.read_coils_safe(addr=0, count=1)\n\nif result is not None:\n    estado = result[0]\n    print(f\"Coil 0: {estado}\")\n</code></pre><p></p> <p>Observa\u00e7\u00f5es importantes:</p> <ul> <li>O endere\u00e7amento \u00e9 zero-based</li> <li>Em caso de falha, o m\u00e9todo retorna None</li> <li>Reconex\u00e3o autom\u00e1tica \u00e9 aplicada se necess\u00e1rio</li> </ul>"},{"location":"quickstart/#escrita-de-coils","title":"Escrita de Coils","text":"<p>Escrita de uma \u00fanica coil: </p><pre><code>ok = client.write_single_coil_safe(addr=0, value=True)\n\nif ok:\n    print(\"Coil escrita com sucesso\")\n</code></pre><p></p> <p>O m\u00e9todo retorna True em caso de sucesso e False em caso de falha.</p>"},{"location":"quickstart/#leitura-de-holding-registers-valores-brutos","title":"Leitura de Holding Registers (valores brutos)","text":"<p>Leitura direta de registradores sem convers\u00e3o de tipo: </p><pre><code>regs = client.read_holding_registers_safe(addr=100, count=2)\n\nif regs is not None:\n    print(regs)\n</code></pre><p></p> <p>Os valores retornados s\u00e3o inteiros sem sinal de 16 bits (UINT16).</p>"},{"location":"quickstart/#leitura-tipada-de-registradores","title":"Leitura tipada de registradores","text":"<p>A biblioteca permite a leitura direta j\u00e1 convertida para tipos Python nativos.</p> <p>Exemplo de leitura de um valor FLOAT32:</p> <pre><code>temperatura = client.read_holding_typed_safe(\n    addr=100,\n    dtype=ModbusDataType.FLOAT32,\n    endian=Endian.BE\n)\n\nif temperatura is not None:\n    print(f\"Temperatura: {temperatura:.2f}\")\n</code></pre> <p>Tipos suportados:</p> <ul> <li>INT16 e UINT16</li> <li>INT32 e UINT32</li> <li>INT64 e UINT64</li> <li>FLOAT32</li> <li>FLOAT64</li> </ul>"},{"location":"quickstart/#escrita-tipada-de-registradores","title":"Escrita tipada de registradores","text":"<p>Exemplo de escrita de um valor INT32: </p><pre><code>ok = client.write_holding_typed_safe(\n    addr=200,\n    value=1500,\n    dtype=ModbusDataType.INT32,\n    endian=Endian.LE\n)\n\nif ok:\n    print(\"Valor escrito com sucesso\")\n</code></pre><p></p> <p>A biblioteca converte automaticamente o valor informado para o formato Modbus correto, respeitando tipo e endianness.</p>"},{"location":"quickstart/#endianness","title":"Endianness","text":"<p>O comportamento de ordena\u00e7\u00e3o de palavras e bytes \u00e9 controlado pelo enum Endian. Valores dispon\u00edveis:</p> <ul> <li>Endian.BE: Big Endian (padr\u00e3o Modbus)</li> <li>Endian.LE: Little Endian (troca de palavras)</li> <li>Endian.BE_SWAP: Big Endian com troca de bytes</li> <li>Endian.LE_SWAP: Little Endian com troca de palavras e bytes</li> </ul> <p>A escolha correta depende do fabricante e da configura\u00e7\u00e3o do CLP ou gateway Modbus.</p> <p>Tratamento de falhas</p> <p>Os m\u00e9todos com sufixo _safe seguem as seguintes regras:</p> <ul> <li>Retornam None ou False em caso de erro</li> <li>Realizam reconex\u00e3o autom\u00e1tica quando a conex\u00e3o \u00e9 perdida</li> <li>Aplicam backoff exponencial configur\u00e1vel</li> <li>Registram logs de erro e advert\u00eancia</li> <li>Cacheiam endere\u00e7os Modbus inv\u00e1lidos para evitar repeti\u00e7\u00e3o de falhas</li> </ul> <p>Exemplo de verifica\u00e7\u00e3o segura: </p><pre><code>valor = client.read_input_typed_safe(\n    addr=10,\n    dtype=ModbusDataType.INT16\n)\n\nif valor is None:\n    print(\"Falha na leitura ou endere\u00e7o inv\u00e1lido\")\n</code></pre><p></p>"},{"location":"quickstart/#encerrando-a-conexao","title":"Encerrando a conex\u00e3o","text":"<p>A conex\u00e3o pode ser encerrada explicitamente quando n\u00e3o for mais necess\u00e1ria: </p><pre><code>client.close()\n</code></pre><p></p>"},{"location":"quickstart/#proximos-passos","title":"Pr\u00f3ximos passos","text":"<p>Ap\u00f3s concluir este Quickstart, recomenda-se:</p> <ul> <li>Ler a se\u00e7\u00e3o de conceitos</li> <li>Entender em detalhe o funcionamento do endianness</li> <li>Consultar a documenta\u00e7\u00e3o completa da API</li> <li>Analisar os exemplos de uso industrial</li> <li>Integrar a biblioteca ao projeto final</li> </ul> <p>Este Quickstart cobre apenas o essencial para iniciar o uso da biblioteca. A documenta\u00e7\u00e3o completa aborda cen\u00e1rios avan\u00e7ados, boas pr\u00e1ticas e decis\u00f5es de projeto.</p>"},{"location":"api/client/","title":"Cliente ModbusTCPResiliente","text":""},{"location":"api/client/#api-modbustcpresiliente","title":"API \u2013 ModbusTCPResiliente","text":"<p>Esta se\u00e7\u00e3o documenta a API p\u00fablica da biblioteca pyModbusTCPtools, com foco na classe <code>ModbusTCPResiliente</code>.</p> <p>O objetivo \u00e9 descrever de forma clara e objetiva o comportamento, os par\u00e2metros e os retornos de cada m\u00e9todo p\u00fablico, sem expor detalhes internos de implementa\u00e7\u00e3o.</p>"},{"location":"api/client/#classe-modbustcpresiliente","title":"Classe ModbusTCPResiliente","text":"<p>A classe <code>ModbusTCPResiliente</code> representa um cliente Modbus TCP resiliente, projetado para uso industrial cont\u00ednuo.</p> <p>Principais caracter\u00edsticas:</p> <ul> <li>Reconex\u00e3o autom\u00e1tica</li> <li>Backoff exponencial</li> <li>Cache de endere\u00e7os inv\u00e1lidos</li> <li>Leitura e escrita tipada</li> <li>Tratamento expl\u00edcito de erros</li> <li>Logging estruturado</li> </ul>"},{"location":"api/client/#criacao-do-cliente","title":"Cria\u00e7\u00e3o do cliente","text":""},{"location":"api/client/#construtor","title":"Construtor","text":"<pre><code>ModbusTCPResiliente(\n    host,\n    port=502,\n    unit_id=1,\n    timeout=3.0,\n    retry_delay=2.0,\n    max_retry_delay=30.0,\n    ping_addr=0,\n    ping_count=1,\n    log_file=\"modbus.log\",\n    console=False,\n    logger=None,\n    invalid_cache_ttl=600,\n    invalid_cache_max=500\n)\n</code></pre>"},{"location":"api/client/#parametros","title":"Par\u00e2metros","text":"<ul> <li> <p>host</p> <p>Endere\u00e7o IP ou hostname do dispositivo Modbus TCP.</p> </li> <li> <p>port</p> <p>Porta TCP utilizada pelo servidor Modbus. Valor padr\u00e3o: <code>502</code>.</p> </li> <li> <p>unit_id</p> <p>Identificador l\u00f3gico do dispositivo Modbus.</p> </li> <li> <p>timeout</p> <p>Tempo m\u00e1ximo de espera por resposta (em segundos).</p> </li> <li> <p>retry_delay</p> <p>Tempo inicial de espera entre tentativas de reconex\u00e3o.</p> </li> <li> <p>max_retry_delay</p> <p>Tempo m\u00e1ximo de espera entre tentativas de reconex\u00e3o.</p> </li> <li> <p>ping_addr</p> <p>Endere\u00e7o utilizado para verificar conectividade ativa.</p> </li> <li> <p>ping_count</p> <p>Quantidade de registradores utilizados no teste de conex\u00e3o.</p> </li> <li> <p>log_file</p> <p>Caminho do arquivo de log. Pode ser <code>None</code> para desabilitar.</p> </li> <li> <p>console</p> <p>Se <code>True</code>, imprime logs tamb\u00e9m no console.</p> </li> <li> <p>logger</p> <p>Logger externo opcional. Se informado, substitui o logger interno.</p> </li> <li> <p>invalid_cache_ttl</p> <p>Tempo de vida (em segundos) do cache de endere\u00e7os inv\u00e1lidos.</p> </li> <li> <p>invalid_cache_max</p> <p>N\u00famero m\u00e1ximo de entradas no cache de endere\u00e7os inv\u00e1lidos.</p> </li> </ul>"},{"location":"api/client/#gerenciamento-de-conexao","title":"Gerenciamento de conex\u00e3o","text":""},{"location":"api/client/#is_connected","title":"is_connected","text":"<p>Verifica se a conex\u00e3o Modbus TCP est\u00e1 ativa por meio de uma leitura real no dispositivo.</p> <pre><code>client.is_connected()\n</code></pre> <ul> <li>Retorna <code>True</code> se a comunica\u00e7\u00e3o estiver funcional</li> <li>Retorna <code>False</code> em caso de falha</li> <li>Pode disparar reconex\u00e3o autom\u00e1tica</li> </ul>"},{"location":"api/client/#close","title":"close","text":"<p>Encerra explicitamente a conex\u00e3o Modbus TCP.</p> <pre><code>client.close()\n</code></pre>"},{"location":"api/client/#leitura-de-bits","title":"Leitura de bits","text":""},{"location":"api/client/#read_coils_safe","title":"read_coils_safe","text":"<pre><code>client.read_coils_safe(addr, count)\n</code></pre> <ul> <li>Retorna lista de booleanos em caso de sucesso</li> <li>Retorna <code>None</code> em caso de falha</li> </ul>"},{"location":"api/client/#read_discrete_inputs_safe","title":"read_discrete_inputs_safe","text":"<pre><code>client.read_discrete_inputs_safe(addr, count)\n</code></pre>"},{"location":"api/client/#escrita-de-bits","title":"Escrita de bits","text":""},{"location":"api/client/#write_single_coil_safe","title":"write_single_coil_safe","text":"<pre><code>client.write_single_coil_safe(addr, value)\n</code></pre>"},{"location":"api/client/#write_multiple_coils_safe","title":"write_multiple_coils_safe","text":"<pre><code>client.write_multiple_coils_safe(addr, values)\n</code></pre>"},{"location":"api/client/#leitura-de-registradores-bruto","title":"Leitura de registradores (bruto)","text":""},{"location":"api/client/#read_holding_registers_safe","title":"read_holding_registers_safe","text":"<pre><code>client.read_holding_registers_safe(addr, count)\n</code></pre>"},{"location":"api/client/#read_input_registers_safe","title":"read_input_registers_safe","text":"<pre><code>client.read_input_registers_safe(addr, count)\n</code></pre>"},{"location":"api/client/#escrita-de-registradores-bruto","title":"Escrita de registradores (bruto)","text":""},{"location":"api/client/#write_single_register_safe","title":"write_single_register_safe","text":"<pre><code>client.write_single_register_safe(addr, value)\n</code></pre>"},{"location":"api/client/#write_multiple_registers_safe","title":"write_multiple_registers_safe","text":"<pre><code>client.write_multiple_registers_safe(addr, values)\n</code></pre>"},{"location":"api/client/#leitura-tipada-de-registradores","title":"Leitura tipada de registradores","text":""},{"location":"api/client/#read_holding_typed_safe","title":"read_holding_typed_safe","text":"<pre><code>client.read_holding_typed_safe(\n    addr,\n    dtype,\n    endian=Endian.BE\n)\n</code></pre>"},{"location":"api/client/#read_input_typed_safe","title":"read_input_typed_safe","text":"<pre><code>client.read_input_typed_safe(\n    addr,\n    dtype,\n    endian=Endian.BE\n)\n</code></pre>"},{"location":"api/client/#escrita-tipada-de-registradores","title":"Escrita tipada de registradores","text":""},{"location":"api/client/#write_holding_typed_safe","title":"write_holding_typed_safe","text":"<pre><code>client.write_holding_typed_safe(\n    addr,\n    value,\n    dtype,\n    endian=Endian.BE\n)\n</code></pre>"},{"location":"api/client/#excecoes","title":"Exce\u00e7\u00f5es","text":"<ul> <li>ModbusConnectionError</li> <li>ModbusProtocolError</li> <li>ModbusReadError</li> <li>ModbusWriteError</li> <li>ModbusConversionError</li> </ul>"},{"location":"api/client/#consideracoes-finais","title":"Considera\u00e7\u00f5es finais","text":"<p>A classe <code>ModbusTCPResiliente</code> foi projetada para uso industrial cont\u00ednuo, oferecendo previsibilidade, robustez e clareza de API.</p>"},{"location":"api/enums/","title":"Enums","text":""},{"location":"api/enums/#api-enums","title":"API \u2013 Enums","text":"<p>Esta se\u00e7\u00e3o documenta os enums p\u00fablicos utilizados pela biblioteca pyModbusTCPtools.</p> <p>Os enums fornecem uma forma expl\u00edcita e segura de configurar tipos de dados Modbus e comportamento de endianness, evitando o uso de valores m\u00e1gicos na aplica\u00e7\u00e3o.</p>"},{"location":"api/enums/#enum-endian","title":"Enum Endian","text":"<p>O enum <code>Endian</code> define a ordena\u00e7\u00e3o de palavras e bytes utilizada na convers\u00e3o de valores Modbus que ocupam m\u00faltiplos registradores.</p> <p>Ele controla separadamente:</p> <ul> <li>Ordem das palavras (word order)</li> <li>Ordem dos bytes dentro da palavra (byte order)</li> </ul> <p>A escolha correta depende do fabricante e da configura\u00e7\u00e3o do dispositivo Modbus.</p>"},{"location":"api/enums/#endianbe","title":"Endian.BE","text":"<p>Big Endian (padr\u00e3o Modbus).</p> <p>Caracter\u00edsticas:</p> <ul> <li>Word order: Big Endian</li> <li>Byte order: Big Endian</li> </ul> <p>Uso t\u00edpico:</p> <ul> <li>CLPs Siemens</li> <li>Implementa\u00e7\u00f5es Modbus cl\u00e1ssicas</li> </ul>"},{"location":"api/enums/#endianle","title":"Endian.LE","text":"<p>Little Endian com troca de palavras (word swap).</p> <p>Caracter\u00edsticas:</p> <ul> <li>Word order: Little Endian</li> <li>Byte order: Big Endian</li> </ul> <p>Uso t\u00edpico:</p> <ul> <li>Alguns CLPs Rockwell</li> <li>Gateways configur\u00e1veis</li> </ul>"},{"location":"api/enums/#endianbe_swap","title":"Endian.BE_SWAP","text":"<p>Big Endian com troca de bytes.</p> <p>Caracter\u00edsticas:</p> <ul> <li>Word order: Big Endian</li> <li>Byte order: Little Endian</li> </ul> <p>Uso t\u00edpico:</p> <ul> <li>Dispositivos que realizam byte swap</li> <li>Equipamentos legados espec\u00edficos</li> </ul>"},{"location":"api/enums/#endianle_swap","title":"Endian.LE_SWAP","text":"<p>Little Endian com troca de palavras e bytes.</p> <p>Caracter\u00edsticas:</p> <ul> <li>Word order: Little Endian</li> <li>Byte order: Little Endian</li> </ul> <p>Uso t\u00edpico:</p> <ul> <li>Casos espec\u00edficos de interoperabilidade</li> </ul>"},{"location":"api/enums/#enum-modbusdatatype","title":"Enum ModbusDataType","text":"<p>O enum <code>ModbusDataType</code> define os tipos de dados suportados pela biblioteca para leitura e escrita tipada.</p> <p>Cada tipo corresponde a um tamanho fixo em bits e a uma quantidade conhecida de registradores Modbus.</p>"},{"location":"api/enums/#int16","title":"INT16","text":"<ul> <li>Tipo inteiro com sinal</li> <li>Tamanho: 16 bits</li> <li>Registradores: 1</li> <li>Range: -32.768 a 32.767</li> </ul>"},{"location":"api/enums/#uint16","title":"UINT16","text":"<ul> <li>Tipo inteiro sem sinal</li> <li>Tamanho: 16 bits</li> <li>Registradores: 1</li> <li>Range: 0 a 65.535</li> </ul>"},{"location":"api/enums/#int32","title":"INT32","text":"<ul> <li>Tipo inteiro com sinal</li> <li>Tamanho: 32 bits</li> <li>Registradores: 2</li> <li>Range: -2.147.483.648 a 2.147.483.647</li> </ul>"},{"location":"api/enums/#uint32","title":"UINT32","text":"<ul> <li>Tipo inteiro sem sinal</li> <li>Tamanho: 32 bits</li> <li>Registradores: 2</li> <li>Range: 0 a 4.294.967.295</li> </ul>"},{"location":"api/enums/#int64","title":"INT64","text":"<ul> <li>Tipo inteiro com sinal</li> <li>Tamanho: 64 bits</li> <li>Registradores: 4</li> <li>Range: -9.223.372.036.854.775.808 a 9.223.372.036.854.775.807</li> </ul>"},{"location":"api/enums/#uint64","title":"UINT64","text":"<ul> <li>Tipo inteiro sem sinal</li> <li>Tamanho: 64 bits</li> <li>Registradores: 4</li> <li>Range: 0 a 18.446.744.073.709.551.615</li> </ul>"},{"location":"api/enums/#float32","title":"FLOAT32","text":"<ul> <li>Tipo ponto flutuante (IEEE 754)</li> <li>Tamanho: 32 bits</li> <li>Registradores: 2</li> <li>Range aproximado: \u00b11,18 \u00d7 10\u207b\u00b3\u2078 a \u00b13,40 \u00d7 10\u00b3\u2078</li> </ul>"},{"location":"api/enums/#float64","title":"FLOAT64","text":"<ul> <li>Tipo ponto flutuante de dupla precis\u00e3o (IEEE 754)</li> <li>Tamanho: 64 bits</li> <li>Registradores: 4</li> <li>Range aproximado: \u00b12,23 \u00d7 10\u207b\u00b3\u2070\u2078 a \u00b11,79 \u00d7 10\u00b3\u2070\u2078</li> </ul>"},{"location":"api/enums/#consideracoes-de-uso","title":"Considera\u00e7\u00f5es de uso","text":"<p>Boas pr\u00e1ticas ao utilizar enums:</p> <ul> <li>Sempre utilize os enums ao inv\u00e9s de valores literais</li> <li>Documente o endianness utilizado por cada dispositivo</li> <li>Centralize a defini\u00e7\u00e3o de tipos e endianness na aplica\u00e7\u00e3o</li> <li>Evite misturar diferentes endianness sem necessidade</li> </ul>"},{"location":"api/enums/#proximo-passo","title":"Pr\u00f3ximo passo","text":"<p>Ap\u00f3s compreender os enums dispon\u00edveis, avance para a documenta\u00e7\u00e3o de Exce\u00e7\u00f5es, onde s\u00e3o detalhados os erros levantados pela biblioteca e como trat\u00e1-los corretamente.</p>"},{"location":"api/exceptions/","title":"Exce\u00e7\u00f5es","text":""},{"location":"api/exceptions/#api-excecoes","title":"API \u2013 Exce\u00e7\u00f5es","text":"<p>Esta se\u00e7\u00e3o documenta as exce\u00e7\u00f5es p\u00fablicas utilizadas pela biblioteca pyModbusTCPtools.</p> <p>As exce\u00e7\u00f5es permitem identificar claramente a causa de uma falha durante a comunica\u00e7\u00e3o Modbus TCP, diferenciando problemas de conex\u00e3o, protocolo, leitura, escrita e convers\u00e3o de dados.</p>"},{"location":"api/exceptions/#hierarquia-de-excecoes","title":"Hierarquia de exce\u00e7\u00f5es","text":"<p>Todas as exce\u00e7\u00f5es da biblioteca herdam da classe base <code>ModbusError</code>.</p> <pre><code>ModbusError\n\u251c\u2500\u2500 ModbusConnectionError\n\u251c\u2500\u2500 ModbusProtocolError\n\u251c\u2500\u2500 ModbusReadError\n\u251c\u2500\u2500 ModbusWriteError\n\u2514\u2500\u2500 ModbusConversionError\n</code></pre>"},{"location":"api/exceptions/#modbuserror","title":"ModbusError","text":"<p>Classe base para todas as exce\u00e7\u00f5es relacionadas ao Modbus.</p> <p>Uso t\u00edpico:</p> <ul> <li>Captura gen\u00e9rica de erros da biblioteca</li> <li>Tratamento comum de falhas Modbus</li> </ul>"},{"location":"api/exceptions/#modbusconnectionerror","title":"ModbusConnectionError","text":"<p>Indica falha de conex\u00e3o TCP ou perda de comunica\u00e7\u00e3o com o dispositivo Modbus.</p> <p>Causas comuns:</p> <ul> <li>Dispositivo desligado</li> <li>Cabo de rede desconectado</li> <li>Timeout de comunica\u00e7\u00e3o</li> <li>Socket encerrado inesperadamente</li> </ul> <p>Esse erro indica um problema de transporte, n\u00e3o de aplica\u00e7\u00e3o Modbus.</p>"},{"location":"api/exceptions/#modbusprotocolerror","title":"ModbusProtocolError","text":"<p>Indica que o dispositivo respondeu com uma exce\u00e7\u00e3o do protocolo Modbus.</p> <p>Exemplos de exce\u00e7\u00f5es Modbus:</p> <ul> <li>Illegal Function</li> <li>Illegal Data Address</li> <li>Illegal Data Value</li> </ul> <p>Caracter\u00edsticas:</p> <ul> <li>A conex\u00e3o TCP pode continuar ativa</li> <li>O erro indica problema de endere\u00e7amento ou fun\u00e7\u00e3o inv\u00e1lida</li> <li>Pode ser cacheado internamente pela biblioteca</li> </ul>"},{"location":"api/exceptions/#modbusreaderror","title":"ModbusReadError","text":"<p>Indica falha durante uma opera\u00e7\u00e3o de leitura Modbus.</p> <p>Pode ocorrer quando:</p> <ul> <li>N\u00e3o h\u00e1 resposta v\u00e1lida do dispositivo</li> <li>O dispositivo retorna dados inconsistentes</li> <li>O cliente Modbus falha sem exce\u00e7\u00e3o expl\u00edcita</li> </ul>"},{"location":"api/exceptions/#modbuswriteerror","title":"ModbusWriteError","text":"<p>Indica falha durante uma opera\u00e7\u00e3o de escrita Modbus.</p> <p>Pode ocorrer quando:</p> <ul> <li>O dispositivo rejeita a escrita</li> <li>A escrita n\u00e3o \u00e9 confirmada</li> <li>O socket falha durante a opera\u00e7\u00e3o</li> </ul>"},{"location":"api/exceptions/#modbusconversionerror","title":"ModbusConversionError","text":"<p>Indica erro durante a convers\u00e3o de dados Modbus para tipos Python.</p> <p>Causas comuns:</p> <ul> <li>Valor fora do range do tipo</li> <li>Quantidade incorreta de registradores</li> <li>Endianness incompat\u00edvel</li> <li>Valor inv\u00e1lido para FLOAT ou DOUBLE</li> </ul> <p>Esse erro indica um problema de interpreta\u00e7\u00e3o de dados, n\u00e3o de comunica\u00e7\u00e3o.</p>"},{"location":"api/exceptions/#uso-tipico-das-excecoes","title":"Uso t\u00edpico das exce\u00e7\u00f5es","text":"<p>Em aplica\u00e7\u00f5es avan\u00e7adas, exce\u00e7\u00f5es podem ser capturadas explicitamente para controle fino do fluxo.</p> <pre><code>from pyModbusTCPtools.exceptions import (\n    ModbusConnectionError,\n    ModbusProtocolError,\n    ModbusConversionError\n)\n\ntry:\n    valor = client.read_holding_typed_safe(\n        addr=100,\n        dtype=ModbusDataType.FLOAT32\n    )\nexcept ModbusProtocolError as exc:\n    print(f\"Erro de protocolo Modbus: {exc}\")\nexcept ModbusConnectionError as exc:\n    print(f\"Falha de conex\u00e3o: {exc}\")\nexcept ModbusConversionError as exc:\n    print(f\"Erro de convers\u00e3o: {exc}\")\n</code></pre>"},{"location":"api/exceptions/#boas-praticas","title":"Boas pr\u00e1ticas","text":"<ul> <li>Diferencie erros de conex\u00e3o de erros de protocolo</li> <li>Trate exce\u00e7\u00f5es conforme a criticidade do erro</li> <li>N\u00e3o ignore exce\u00e7\u00f5es silenciosamente</li> <li>Utilize logs para diagn\u00f3stico em produ\u00e7\u00e3o</li> <li>Evite capturar exce\u00e7\u00f5es gen\u00e9ricas sem an\u00e1lise</li> </ul>"},{"location":"api/exceptions/#proximo-passo","title":"Pr\u00f3ximo passo","text":"<p>Ap\u00f3s compreender as exce\u00e7\u00f5es dispon\u00edveis, retorne \u00e0 documenta\u00e7\u00e3o da API para consolidar o uso da biblioteca ou avance para os exemplos pr\u00e1ticos.</p>"},{"location":"concepts/endianness/","title":"Endianness","text":""},{"location":"concepts/endianness/#endianness","title":"Endianness","text":"<p>Esta se\u00e7\u00e3o descreve como a biblioteca pyModbusTCPtools trata a ordena\u00e7\u00e3o de palavras e bytes (endianness) ao converter valores Modbus para tipos Python e vice-versa.</p> <p>O entendimento correto de endianness \u00e9 essencial para evitar leituras incorretas de valores num\u00e9ricos em sistemas Modbus.</p>"},{"location":"concepts/endianness/#o-problema-do-endianness-no-modbus","title":"O problema do endianness no Modbus","text":"<p>O protocolo Modbus define registradores de 16 bits, mas n\u00e3o define como valores maiores (32 ou 64 bits) devem ser organizados quando distribu\u00eddos em m\u00faltiplos registradores.</p> <p>Isso faz com que cada fabricante adote sua pr\u00f3pria conven\u00e7\u00e3o para:</p> <ul> <li>Ordem das palavras (word order)</li> <li>Ordem dos bytes dentro de cada palavra (byte order)</li> </ul> <p>Sem essa defini\u00e7\u00e3o clara, o mesmo conjunto de registradores pode representar valores completamente diferentes.</p>"},{"location":"concepts/endianness/#conceitos-basicos","title":"Conceitos b\u00e1sicos","text":""},{"location":"concepts/endianness/#byte-order","title":"Byte order","text":"<p>Refere-se \u00e0 ordem dos bytes dentro de uma palavra de 16 bits.</p> <ul> <li>Big Endian: byte mais significativo primeiro</li> <li>Little Endian: byte menos significativo primeiro</li> </ul>"},{"location":"concepts/endianness/#word-order","title":"Word order","text":"<p>Refere-se \u00e0 ordem dos registradores quando um valor ocupa mais de um registrador.</p> <ul> <li>Big Endian (word order): registrador mais significativo primeiro</li> <li>Little Endian (word swap): registrador menos significativo primeiro</li> </ul>"},{"location":"concepts/endianness/#endianness-na-pymodbustcptools","title":"Endianness na pyModbusTCPtools","text":"<p>A biblioteca controla explicitamente o comportamento de endianness por meio do enum <code>Endian</code>.</p> <p>Esse enum permite tratar separadamente:</p> <ul> <li>Ordem de palavras</li> <li>Ordem de bytes</li> </ul>"},{"location":"concepts/endianness/#enum-endian","title":"Enum Endian","text":"<p>Os valores dispon\u00edveis s\u00e3o:</p>"},{"location":"concepts/endianness/#endianbe","title":"Endian.BE","text":"<ul> <li>Word order: Big Endian</li> <li>Byte order: Big Endian</li> <li>Comportamento padr\u00e3o do Modbus</li> </ul> <p>Uso t\u00edpico:</p> <ul> <li>CLPs Siemens (padr\u00e3o)</li> <li>Implementa\u00e7\u00f5es Modbus cl\u00e1ssicas</li> </ul>"},{"location":"concepts/endianness/#endianle","title":"Endian.LE","text":"<ul> <li>Word order: Little Endian (word swap)</li> <li>Byte order: Big Endian</li> </ul> <p>Uso t\u00edpico:</p> <ul> <li>Alguns CLPs Rockwell</li> <li>Gateways configur\u00e1veis</li> </ul>"},{"location":"concepts/endianness/#endianbe_swap","title":"Endian.BE_SWAP","text":"<ul> <li>Word order: Big Endian</li> <li>Byte order: Little Endian (byte swap)</li> </ul> <p>Uso t\u00edpico:</p> <ul> <li>Equipamentos que trocam bytes dentro da palavra</li> <li>Dispositivos legados espec\u00edficos</li> </ul>"},{"location":"concepts/endianness/#endianle_swap","title":"Endian.LE_SWAP","text":"<ul> <li>Word order: Little Endian</li> <li>Byte order: Little Endian</li> </ul> <p>Uso t\u00edpico:</p> <ul> <li>Combina\u00e7\u00e3o de word swap e byte swap</li> <li>Casos espec\u00edficos de interoperabilidade</li> </ul>"},{"location":"concepts/endianness/#exemplos-praticos","title":"Exemplos pr\u00e1ticos","text":""},{"location":"concepts/endianness/#exemplo-de-leitura-float32-big-endian","title":"Exemplo de leitura FLOAT32 Big Endian","text":"<pre><code>valor = client.read_holding_typed_safe(\n    addr=100,\n    dtype=ModbusDataType.FLOAT32,\n    endian=Endian.BE\n)\n</code></pre>"},{"location":"concepts/endianness/#exemplo-de-leitura-float32-com-word-swap","title":"Exemplo de leitura FLOAT32 com word swap","text":"<pre><code>valor = client.read_holding_typed_safe(\n    addr=100,\n    dtype=ModbusDataType.FLOAT32,\n    endian=Endian.LE\n)\n</code></pre>"},{"location":"concepts/endianness/#exemplo-de-escrita-int32-com-byte-swap","title":"Exemplo de escrita INT32 com byte swap","text":"<pre><code>client.write_holding_typed_safe(\n    addr=200,\n    value=12345,\n    dtype=ModbusDataType.INT32,\n    endian=Endian.BE_SWAP\n)\n</code></pre>"},{"location":"concepts/endianness/#como-identificar-o-endianness-correto","title":"Como identificar o endianness correto","text":"<p>Para identificar o endianness correto do dispositivo Modbus:</p> <ul> <li>Consulte o manual do fabricante</li> <li>Verifique exemplos fornecidos pelo fornecedor</li> <li>Compare leituras com valores conhecidos</li> <li>Teste combina\u00e7\u00f5es de endianness at\u00e9 obter valores coerentes</li> <li>Nunca assuma o padr\u00e3o sem valida\u00e7\u00e3o.</li> </ul>"},{"location":"concepts/endianness/#erros-comuns-relacionados-a-endianness","title":"Erros comuns relacionados a endianness","text":"<p>Os sintomas mais comuns de endianness incorreto incluem:</p> <ul> <li>Valores muito altos ou muito baixos</li> <li>Valores negativos inesperados</li> <li>N\u00fameros aparentemente aleat\u00f3rios</li> <li>Oscila\u00e7\u00f5es incoerentes em leituras est\u00e1veis</li> </ul> <p>A biblioteca n\u00e3o tenta \"adivinhar\" o endianness correto. Ele deve ser informado explicitamente.</p>"},{"location":"concepts/endianness/#boas-praticas","title":"Boas pr\u00e1ticas","text":"<ul> <li>Documente o endianness utilizado por cada dispositivo</li> <li>Centralize a configura\u00e7\u00e3o de endianness na aplica\u00e7\u00e3o</li> <li>Evite misturar endianness diferentes no mesmo projeto</li> <li>Valide sempre com valores de refer\u00eancia</li> </ul>"},{"location":"concepts/endianness/#proximo-passo","title":"Pr\u00f3ximo passo","text":"<p>Ap\u00f3s entender o funcionamento do endianness, avance para a se\u00e7\u00e3o Tratamento de Erros, onde s\u00e3o detalhadas as exce\u00e7\u00f5es, falhas de comunica\u00e7\u00e3o e estrat\u00e9gias de recupera\u00e7\u00e3o adotadas pela biblioteca.</p>"},{"location":"concepts/error_handling/","title":"Tratamento de Erros","text":""},{"location":"concepts/error_handling/#tratamento-de-erros","title":"Tratamento de Erros","text":"<p>Esta se\u00e7\u00e3o descreve como a biblioteca pyModbusTCPtools trata erros de comunica\u00e7\u00e3o, exce\u00e7\u00f5es do protocolo Modbus e falhas de convers\u00e3o de dados.</p> <p>O objetivo \u00e9 permitir que aplica\u00e7\u00f5es industriais consigam distinguir claramente a causa da falha e tomem decis\u00f5es corretas, sem depender de mensagens gen\u00e9ricas ou comportamentos impl\u00edcitos.</p>"},{"location":"concepts/error_handling/#tipos-de-erro-em-sistemas-modbus","title":"Tipos de erro em sistemas Modbus","text":"<p>Em aplica\u00e7\u00f5es Modbus TCP, erros podem ocorrer por diferentes motivos. A biblioteca diferencia explicitamente essas situa\u00e7\u00f5es.</p> <p>As categorias principais s\u00e3o:</p> <ul> <li>Falhas de conex\u00e3o</li> <li>Exce\u00e7\u00f5es do protocolo Modbus</li> <li>Falhas de leitura ou escrita</li> <li>Erros de convers\u00e3o de dados</li> </ul> <p>Cada categoria \u00e9 representada por uma exce\u00e7\u00e3o espec\u00edfica.</p>"},{"location":"concepts/error_handling/#filosofia-de-tratamento-da-biblioteca","title":"Filosofia de tratamento da biblioteca","text":"<p>A biblioteca foi projetada com os seguintes princ\u00edpios:</p> <ul> <li>Falhas de comunica\u00e7\u00e3o s\u00e3o eventos normais</li> <li>Erros n\u00e3o devem derrubar a aplica\u00e7\u00e3o</li> <li>O tipo do erro deve ser expl\u00edcito</li> <li>O chamador decide como reagir</li> <li>Reconex\u00e3o deve ser autom\u00e1tica quando poss\u00edvel</li> </ul> <p>Por isso, a API oferece m\u00e9todos seguros (<code>_safe</code>) e exce\u00e7\u00f5es bem definidas.</p>"},{"location":"concepts/error_handling/#excecoes-disponiveis","title":"Exce\u00e7\u00f5es dispon\u00edveis","text":"<p>Todas as exce\u00e7\u00f5es da biblioteca herdam de <code>ModbusError</code>.</p>"},{"location":"concepts/error_handling/#modbuserror","title":"ModbusError","text":"<p>Exce\u00e7\u00e3o base para todos os erros relacionados ao Modbus.</p> <p>Uso t\u00edpico: - Captura gen\u00e9rica de erros da biblioteca</p>"},{"location":"concepts/error_handling/#modbusconnectionerror","title":"ModbusConnectionError","text":"<p>Indica falha de conex\u00e3o TCP ou perda de comunica\u00e7\u00e3o com o dispositivo.</p> <p>Causas comuns: - CLP desligado - Cabo desconectado - Timeout de rede - Socket encerrado</p>"},{"location":"concepts/error_handling/#modbusprotocolerror","title":"ModbusProtocolError","text":"<p>Indica que o dispositivo Modbus respondeu com uma exce\u00e7\u00e3o de protocolo, como:</p> <ul> <li>Illegal Function</li> <li>Illegal Data Address</li> <li>Illegal Data Value</li> </ul> <p>Nesse caso: - A conex\u00e3o TCP pode continuar ativa - O erro indica problema de aplica\u00e7\u00e3o ou endere\u00e7amento</p>"},{"location":"concepts/error_handling/#modbusreaderror","title":"ModbusReadError","text":"<p>Indica falha durante uma opera\u00e7\u00e3o de leitura Modbus.</p> <p>Pode ocorrer quando: - N\u00e3o h\u00e1 resposta v\u00e1lida - O dispositivo retorna dados inconsistentes - O cliente Modbus falha sem exce\u00e7\u00e3o expl\u00edcita</p>"},{"location":"concepts/error_handling/#modbuswriteerror","title":"ModbusWriteError","text":"<p>Indica falha durante uma opera\u00e7\u00e3o de escrita Modbus.</p> <p>Pode ocorrer quando: - O dispositivo rejeita a escrita - A escrita n\u00e3o \u00e9 confirmada - O socket falha durante a opera\u00e7\u00e3o</p>"},{"location":"concepts/error_handling/#modbusconversionerror","title":"ModbusConversionError","text":"<p>Indica erro na convers\u00e3o de dados Modbus para tipos Python.</p> <p>Causas comuns: - Valor fora do range do tipo - Quantidade incorreta de registradores - Endianness incompat\u00edvel - Valor inv\u00e1lido para FLOAT ou DOUBLE</p>"},{"location":"concepts/error_handling/#metodos-_safe","title":"M\u00e9todos <code>_safe</code>","text":"<p>Os m\u00e9todos com sufixo <code>_safe</code> s\u00e3o projetados para uso direto em aplica\u00e7\u00f5es.</p> <p>Caracter\u00edsticas principais:</p> <ul> <li>Nunca levantam exce\u00e7\u00f5es n\u00e3o tratadas</li> <li>Retornam <code>None</code> ou <code>False</code> em caso de falha</li> <li>Realizam reconex\u00e3o autom\u00e1tica</li> <li>Aplicam backoff exponencial</li> <li>Registram logs detalhados</li> </ul>"},{"location":"concepts/error_handling/#exemplo-de-leitura-segura","title":"Exemplo de leitura segura","text":"<pre><code>valor = client.read_holding_typed_safe(\n    addr=100,\n    dtype=ModbusDataType.FLOAT32,\n    endian=Endian.BE\n)\n\nif valor is None:\n    print(\"Falha na leitura ou endere\u00e7o inv\u00e1lido\")\n</code></pre>"},{"location":"concepts/error_handling/#uso-explicito-de-excecoes","title":"Uso expl\u00edcito de exce\u00e7\u00f5es","text":"<p>Para aplica\u00e7\u00f5es que precisam de controle mais fino, \u00e9 poss\u00edvel utilizar exce\u00e7\u00f5es diretamente.</p> <pre><code>from pyModbusTCPtools.exceptions import ModbusConnectionError, ModbusProtocolError\n\ntry:\n    valor = client.read_holding_typed_safe(\n        addr=100,\n        dtype=ModbusDataType.INT32\n    )\nexcept ModbusProtocolError as exc:\n    print(f\"Erro de protocolo Modbus: {exc}\")\nexcept ModbusConnectionError as exc:\n    print(f\"Falha de conex\u00e3o: {exc}\")\n</code></pre>"},{"location":"concepts/error_handling/#cache-de-enderecos-invalidos","title":"Cache de endere\u00e7os inv\u00e1lidos","text":"<p>A biblioteca mant\u00e9m um cache interno de endere\u00e7os inv\u00e1lidos, utilizado quando o dispositivo retorna exce\u00e7\u00f5es como <code>Illegal Data Address</code>.</p>"},{"location":"concepts/error_handling/#comportamento","title":"Comportamento","text":"<ul> <li>Endere\u00e7os inv\u00e1lidos s\u00e3o colocados em quarentena</li> <li>Novas tentativas s\u00e3o bloqueadas temporariamente</li> <li>O cache possui tempo de expira\u00e7\u00e3o configur\u00e1vel</li> <li>Evita sobrecarga desnecess\u00e1ria no dispositivo</li> </ul> <p>Esse mecanismo \u00e9 totalmente transparente para o usu\u00e1rio.</p>"},{"location":"concepts/error_handling/#logs-e-diagnostico","title":"Logs e diagn\u00f3stico","text":"<p>A biblioteca gera logs estruturados que auxiliam no diagn\u00f3stico de falhas.</p> <p>Os logs podem incluir:</p> <ul> <li>Tentativas de reconex\u00e3o</li> <li>Perda de comunica\u00e7\u00e3o</li> <li>Exce\u00e7\u00f5es Modbus</li> <li>Erros de convers\u00e3o</li> </ul> <p>O n\u00edvel de detalhe pode ser ajustado via configura\u00e7\u00e3o do logger.</p>"},{"location":"concepts/error_handling/#boas-praticas","title":"Boas pr\u00e1ticas","text":"<ul> <li>Sempre valide retornos None ou False</li> <li>Diferencie erro de protocolo de erro de conex\u00e3o</li> <li>N\u00e3o trate exce\u00e7\u00f5es de forma gen\u00e9rica sem an\u00e1lise</li> <li>Registre logs em ambiente de produ\u00e7\u00e3o</li> <li>Nunca assuma que um endere\u00e7o Modbus existe</li> </ul>"},{"location":"concepts/error_handling/#proximo-passo","title":"Pr\u00f3ximo passo","text":"<p>Ap\u00f3s compreender o tratamento de erros, avance para a documenta\u00e7\u00e3o da API, onde a classe ModbusTCPResiliente e seus m\u00e9todos p\u00fablicos s\u00e3o descritos em detalhe.</p>"},{"location":"concepts/modbus_basics/","title":"Fundamentos Modbus","text":""},{"location":"concepts/modbus_basics/#fundamentos-do-modbus","title":"Fundamentos do Modbus","text":"<p>Esta se\u00e7\u00e3o apresenta os conceitos fundamentais do protocolo Modbus, necess\u00e1rios para o uso correto da biblioteca pyModbusTCPtools.</p> <p>O objetivo n\u00e3o \u00e9 ensinar Modbus do zero, mas alinhar terminologia, endere\u00e7amento e comportamento conforme utilizado pela biblioteca.</p>"},{"location":"concepts/modbus_basics/#o-que-e-modbus","title":"O que \u00e9 Modbus","text":"<p>Modbus \u00e9 um protocolo de comunica\u00e7\u00e3o industrial criado originalmente para troca de dados entre dispositivos de automa\u00e7\u00e3o, como CLPs, sensores, inversores e gateways.</p> <p>Caracter\u00edsticas principais:</p> <ul> <li>Protocolo simples e amplamente adotado</li> <li>Modelo mestre/escravo (cliente/servidor)</li> <li>Comunica\u00e7\u00e3o baseada em leitura e escrita de \u00e1reas de mem\u00f3ria</li> <li>Independente de fabricante</li> </ul> <p>A biblioteca pyModbusTCPtools trabalha exclusivamente com Modbus TCP, que utiliza TCP/IP como camada de transporte.</p>"},{"location":"concepts/modbus_basics/#modbus-tcp","title":"Modbus TCP","text":"<p>No Modbus TCP:</p> <ul> <li>A comunica\u00e7\u00e3o ocorre sobre TCP/IP</li> <li>A porta padr\u00e3o \u00e9 502</li> <li>N\u00e3o h\u00e1 checksum (CRC), pois a confiabilidade \u00e9 garantida pelo TCP</li> <li>O campo <code>Unit ID</code> identifica o dispositivo l\u00f3gico</li> </ul> <p>A biblioteca atua como cliente Modbus TCP, iniciando todas as requisi\u00e7\u00f5es.</p>"},{"location":"concepts/modbus_basics/#modelo-de-dados-modbus","title":"Modelo de dados Modbus","text":"<p>O protocolo Modbus organiza os dados em quatro \u00e1reas l\u00f3gicas, cada uma com comportamento espec\u00edfico.</p>"},{"location":"concepts/modbus_basics/#coils","title":"Coils","text":"<ul> <li>Tipo: booleano (0 ou 1)</li> <li>Fun\u00e7\u00e3o: escrita e leitura</li> <li>Uso t\u00edpico: comandos digitais (liga/desliga)</li> </ul> <p>Exemplo de uso: - Partida de motor - Habilita\u00e7\u00e3o de controle</p>"},{"location":"concepts/modbus_basics/#discrete-inputs","title":"Discrete Inputs","text":"<ul> <li>Tipo: booleano</li> <li>Fun\u00e7\u00e3o: somente leitura</li> <li>Uso t\u00edpico: estados de sensores digitais</li> </ul> <p>Exemplo de uso: - Fim de curso - Chaves de seguran\u00e7a</p>"},{"location":"concepts/modbus_basics/#input-registers","title":"Input Registers","text":"<ul> <li>Tipo: registrador de 16 bits (UINT16)</li> <li>Fun\u00e7\u00e3o: somente leitura</li> <li>Uso t\u00edpico: medi\u00e7\u00f5es e valores anal\u00f3gicos</li> </ul> <p>Exemplo de uso: - Temperatura - Press\u00e3o - Vaz\u00e3o</p>"},{"location":"concepts/modbus_basics/#holding-registers","title":"Holding Registers","text":"<ul> <li>Tipo: registrador de 16 bits (UINT16)</li> <li>Fun\u00e7\u00e3o: leitura e escrita</li> <li>Uso t\u00edpico: setpoints e par\u00e2metros</li> </ul> <p>Exemplo de uso: - Setpoint de velocidade - Limites de processo - Configura\u00e7\u00f5es gerais</p>"},{"location":"concepts/modbus_basics/#enderecamento-modbus","title":"Endere\u00e7amento Modbus","text":"<p>A biblioteca pyModbusTCPtools utiliza endere\u00e7amento zero-based, conforme a especifica\u00e7\u00e3o do Modbus TCP e a maioria das bibliotecas Python.</p> <p>Isso significa:</p> <ul> <li>Coil 0 \u2192 endere\u00e7o <code>0</code></li> <li>Holding Register 40001 \u2192 endere\u00e7o <code>0</code></li> <li>Input Register 30001 \u2192 endere\u00e7o <code>0</code></li> </ul> <p>O uso de endere\u00e7os baseados em 1 (ex.: 40001, 30001) n\u00e3o \u00e9 utilizado internamente.</p>"},{"location":"concepts/modbus_basics/#tamanho-dos-dados","title":"Tamanho dos dados","text":"<p>Cada registrador Modbus possui 16 bits.</p> <p>Tipos de dados maiores ocupam m\u00faltiplos registradores:</p> <ul> <li>INT32 / UINT32 \u2192 2 registradores</li> <li>FLOAT32 \u2192 2 registradores</li> <li>INT64 / UINT64 \u2192 4 registradores</li> <li>FLOAT64 \u2192 4 registradores</li> </ul> <p>A biblioteca realiza automaticamente esse c\u00e1lculo quando se utiliza leitura ou escrita tipada.</p>"},{"location":"concepts/modbus_basics/#conversao-de-tipos","title":"Convers\u00e3o de tipos","text":"<p>O protocolo Modbus n\u00e3o define tipos de dados complexos, apenas registradores de 16 bits.</p> <p>A interpreta\u00e7\u00e3o de tipos como <code>INT</code>, <code>FLOAT</code> e <code>DOUBLE</code> \u00e9 feita por conven\u00e7\u00e3o entre cliente e servidor.</p> <p>A biblioteca pyModbusTCPtools fornece:</p> <ul> <li>Convers\u00e3o autom\u00e1tica de tipos</li> <li>Valida\u00e7\u00e3o de tamanho</li> <li>Tratamento de overflow</li> <li>Exce\u00e7\u00f5es claras em caso de erro</li> </ul>"},{"location":"concepts/modbus_basics/#endianness","title":"Endianness","text":"<p>Quando m\u00faltiplos registradores s\u00e3o usados para representar um valor, \u00e9 necess\u00e1rio definir a ordem correta:</p> <ul> <li>Ordem das palavras (word order)</li> <li>Ordem dos bytes dentro de cada palavra</li> </ul> <p>Esse comportamento \u00e9 controlado explicitamente pelo enum <code>Endian</code>.</p> <p>A escolha correta depende do fabricante e da configura\u00e7\u00e3o do dispositivo Modbus.</p> <p>A se\u00e7\u00e3o Endianness da documenta\u00e7\u00e3o aborda esse tema em detalhes.</p>"},{"location":"concepts/modbus_basics/#excecoes-modbus","title":"Exce\u00e7\u00f5es Modbus","text":"<p>O protocolo Modbus define exce\u00e7\u00f5es padronizadas, como:</p> <ul> <li>Illegal Function</li> <li>Illegal Data Address</li> <li>Illegal Data Value</li> </ul> <p>Essas exce\u00e7\u00f5es indicam erro de aplica\u00e7\u00e3o, n\u00e3o necessariamente falha de comunica\u00e7\u00e3o.</p> <p>A biblioteca diferencia claramente:</p> <ul> <li>Erros de conex\u00e3o</li> <li>Erros de protocolo Modbus</li> <li>Erros de leitura e escrita</li> <li>Erros de convers\u00e3o de dados</li> </ul>"},{"location":"concepts/modbus_basics/#consideracoes-praticas","title":"Considera\u00e7\u00f5es pr\u00e1ticas","text":"<p>Ao trabalhar com Modbus TCP em ambiente industrial:</p> <ul> <li>Sempre confirme o endere\u00e7amento real no CLP</li> <li>Verifique o tipo de dado esperado</li> <li>Aten\u00e7\u00e3o especial ao endianness</li> <li>Trate falhas de comunica\u00e7\u00e3o como eventos normais</li> <li>N\u00e3o assuma que todos os endere\u00e7os existem</li> </ul> <p>A biblioteca foi projetada considerando essas premissas.</p>"},{"location":"concepts/modbus_basics/#proximo-passo","title":"Pr\u00f3ximo passo","text":"<p>Ap\u00f3s compreender os fundamentos do Modbus, avance para a se\u00e7\u00e3o Endianness, onde s\u00e3o detalhadas as combina\u00e7\u00f5es de ordena\u00e7\u00e3o de palavras e bytes e seus impactos pr\u00e1ticos.</p>"},{"location":"examples/read_coils/","title":"Leitura de Coils","text":""},{"location":"examples/read_coils/#exemplo-leitura-de-coils","title":"Exemplo \u2013 Leitura de Coils","text":"<p>Este exemplo demonstra como realizar a leitura de coils (valores booleanos) utilizando a biblioteca pyModbusTCPtools de forma segura.</p> <p>A leitura de coils \u00e9 normalmente utilizada para verificar estados digitais, como comandos, sa\u00eddas ou flags internas de CLPs e dispositivos Modbus TCP.</p>"},{"location":"examples/read_coils/#cenario-tipico","title":"Cen\u00e1rio t\u00edpico","text":"<ul> <li>Leitura do estado de uma sa\u00edda digital</li> <li>Verifica\u00e7\u00e3o de comando ligado/desligado</li> <li>Monitoramento de bits de status</li> </ul> <p>Neste exemplo, ser\u00e1 realizada a leitura da coil no endere\u00e7o 0.</p>"},{"location":"examples/read_coils/#importacoes","title":"Importa\u00e7\u00f5es","text":"<pre><code>from pyModbusTCPtools import ModbusTCPResiliente\n</code></pre>"},{"location":"examples/read_coils/#criacao-do-cliente","title":"Cria\u00e7\u00e3o do cliente","text":"<pre><code>client = ModbusTCPResiliente(\n    host=\"192.168.0.10\",\n    unit_id=1,\n    timeout=3.0,\n    console=True\n)\n</code></pre>"},{"location":"examples/read_coils/#leitura-de-uma-coil","title":"Leitura de uma coil","text":"<pre><code>result = client.read_coils_safe(addr=0, count=1)\n\nif result is not None:\n    estado = result[0]\n    print(f\"Estado da coil 0: {estado}\")\nelse:\n    print(\"Falha na leitura da coil\")\n</code></pre>"},{"location":"examples/read_coils/#comportamento-do-metodo","title":"Comportamento do m\u00e9todo","text":"<p>O m\u00e9todo <code>read_coils_safe</code> possui o seguinte comportamento:</p> <ul> <li>Retorna uma lista de valores booleanos em caso de sucesso</li> <li>Retorna <code>None</code> em caso de falha</li> <li>Realiza reconex\u00e3o autom\u00e1tica se necess\u00e1rio</li> <li>Aplica backoff exponencial em falhas consecutivas</li> <li>Registra logs detalhados</li> </ul>"},{"location":"examples/read_coils/#observacoes-importantes","title":"Observa\u00e7\u00f5es importantes","text":"<ul> <li>O endere\u00e7amento \u00e9 zero-based</li> <li>Sempre valide o retorno antes de acessar o valor</li> <li>N\u00e3o assuma que o endere\u00e7o da coil existe no dispositivo</li> <li>Em ambientes industriais, falhas de leitura devem ser tratadas como eventos normais</li> </ul>"},{"location":"examples/read_coils/#encerrando-a-conexao","title":"Encerrando a conex\u00e3o","text":"<p>Ap\u00f3s finalizar a leitura, a conex\u00e3o pode ser encerrada explicitamente:</p> <pre><code>client.close()\n</code></pre>"},{"location":"examples/read_discrete_inputs/","title":"Leitura de Discrete Inputs","text":""},{"location":"examples/read_discrete_inputs/#exemplo-leitura-de-discrete-inputs","title":"Exemplo \u2013 Leitura de Discrete Inputs","text":"<p>Este exemplo demonstra como realizar a leitura de Discrete Inputs (entradas digitais somente leitura) utilizando a biblioteca pyModbusTCPtools de forma segura.</p> <p>Discrete Inputs s\u00e3o normalmente utilizados para leitura de sensores digitais, chaves de fim de curso, bot\u00f5es e sinais de estado que n\u00e3o podem ser escritos pelo cliente Modbus.</p>"},{"location":"examples/read_discrete_inputs/#cenario-tipico","title":"Cen\u00e1rio t\u00edpico","text":"<ul> <li>Leitura de sensores digitais</li> <li>Monitoramento de fim de curso</li> <li>Verifica\u00e7\u00e3o de estados de seguran\u00e7a</li> <li>Leitura de entradas f\u00edsicas de CLPs e m\u00f3dulos remotos</li> </ul> <p>Neste exemplo, ser\u00e1 realizada a leitura de Discrete Inputs a partir do endere\u00e7o 0.</p>"},{"location":"examples/read_discrete_inputs/#importacoes","title":"Importa\u00e7\u00f5es","text":"<pre><code>from pyModbusTCPtools import ModbusTCPResiliente\n</code></pre>"},{"location":"examples/read_discrete_inputs/#criacao-do-cliente","title":"Cria\u00e7\u00e3o do cliente","text":"<pre><code>client = ModbusTCPResiliente(\n    host=\"192.168.0.10\",\n    unit_id=1,\n    timeout=3.0,\n    console=True\n)\n</code></pre>"},{"location":"examples/read_discrete_inputs/#leitura-de-discrete-inputs","title":"Leitura de Discrete Inputs","text":""},{"location":"examples/read_discrete_inputs/#leitura-de-uma-entrada-digital","title":"Leitura de uma entrada digital","text":"<pre><code>result = client.read_discrete_inputs_safe(addr=0, count=1)\n\nif result is not None:\n    estado = result[0]\n    print(f\"Discrete Input 0: {estado}\")\nelse:\n    print(\"Falha na leitura do Discrete Input\")\n</code></pre>"},{"location":"examples/read_discrete_inputs/#leitura-de-multiplas-entradas-digitais","title":"Leitura de m\u00faltiplas entradas digitais","text":"<pre><code>result = client.read_discrete_inputs_safe(addr=10, count=4)\n\nif result is not None:\n    for i, value in enumerate(result):\n        print(f\"Discrete Input {10 + i}: {value}\")\nelse:\n    print(\"Falha na leitura dos Discrete Inputs\")\n</code></pre>"},{"location":"examples/read_discrete_inputs/#comportamento-do-metodo","title":"Comportamento do m\u00e9todo","text":"<p>O m\u00e9todo <code>read_discrete_inputs_safe</code> possui o seguinte comportamento:</p> <ul> <li>Retorna uma lista de valores booleanos em caso de sucesso</li> <li>Retorna <code>None</code> em caso de falha</li> <li>Realiza reconex\u00e3o autom\u00e1tica se necess\u00e1rio</li> <li>Aplica backoff exponencial em falhas consecutivas</li> <li>Registra logs detalhados</li> </ul>"},{"location":"examples/read_discrete_inputs/#observacoes-importantes","title":"Observa\u00e7\u00f5es importantes","text":"<ul> <li>O endere\u00e7amento \u00e9 zero-based</li> <li>Discrete Inputs s\u00e3o somente leitura</li> <li>Sempre valide o retorno antes de acessar os valores</li> <li>N\u00e3o assuma que o endere\u00e7o da entrada existe no dispositivo</li> <li>Em ambientes industriais, falhas de leitura devem ser tratadas como eventos normais</li> </ul>"},{"location":"examples/read_discrete_inputs/#encerrando-a-conexao","title":"Encerrando a conex\u00e3o","text":"<p>Ap\u00f3s finalizar as leituras, a conex\u00e3o pode ser encerrada explicitamente:</p> <pre><code>client.close()\n</code></pre>"},{"location":"examples/read_floats32bits/","title":"Leitura de Ponto Flutuante de 32 Bits","text":""},{"location":"examples/read_floats32bits/#exemplo-leitura-de-ponto-flutuante-de-32-bits-float32","title":"Exemplo \u2013 Leitura de Ponto Flutuante de 32 Bits (FLOAT32)","text":"<p>Este exemplo demonstra como realizar a leitura de valores em ponto flutuante de 32 bits (FLOAT32) utilizando a biblioteca pyModbusTCPtools.</p> <p>Valores FLOAT32 ocupam dois registradores Modbus consecutivos e representam n\u00fameros reais conforme o padr\u00e3o IEEE 754.</p>"},{"location":"examples/read_floats32bits/#cenario-tipico","title":"Cen\u00e1rio t\u00edpico","text":"<ul> <li>Leitura de temperatura</li> <li>Leitura de press\u00e3o</li> <li>Leitura de vaz\u00e3o</li> <li>Leitura de n\u00edveis anal\u00f3gicos em engenharia</li> </ul> <p>Neste exemplo, ser\u00e1 realizada a leitura a partir do Holding Register no endere\u00e7o 400.</p>"},{"location":"examples/read_floats32bits/#importacoes","title":"Importa\u00e7\u00f5es","text":"<pre><code>from pyModbusTCPtools import (\n    ModbusTCPResiliente,\n    ModbusDataType,\n    Endian\n)\n</code></pre>"},{"location":"examples/read_floats32bits/#criacao-do-cliente","title":"Cria\u00e7\u00e3o do cliente","text":"<pre><code>client = ModbusTCPResiliente(\n    host=\"192.168.0.10\",\n    unit_id=1,\n    timeout=3.0,\n    console=True\n)\n</code></pre>"},{"location":"examples/read_floats32bits/#leitura-de-float32","title":"Leitura de FLOAT32","text":"<pre><code>valor_float32 = client.read_holding_typed_safe(\n    addr=400,\n    dtype=ModbusDataType.FLOAT32,\n    endian=Endian.BE\n)\n\nif valor_float32 is not None:\n    print(f\"FLOAT32 lido: {valor_float32}\")\nelse:\n    print(\"Falha na leitura do FLOAT32\")\n</code></pre>"},{"location":"examples/read_floats32bits/#observacao-sobre-endianness","title":"Observa\u00e7\u00e3o sobre endianness","text":"<p>Valores FLOAT32 dependem diretamente da correta configura\u00e7\u00e3o de endianness.</p> <p>Caso o valor lido n\u00e3o seja coerente, teste outras op\u00e7\u00f5es:</p> <ul> <li><code>Endian.LE</code></li> <li><code>Endian.BE_SWAP</code></li> <li><code>Endian.LE_SWAP</code></li> </ul> <p>A biblioteca n\u00e3o tenta inferir automaticamente o endianness correto.</p>"},{"location":"examples/read_floats32bits/#caracteristicas-do-float32","title":"Caracter\u00edsticas do FLOAT32","text":"<ul> <li>Padr\u00e3o IEEE 754</li> <li>32 bits de largura</li> <li>Ocupa 2 registradores Modbus</li> <li>Representa n\u00fameros reais com casas decimais</li> </ul>"},{"location":"examples/read_floats32bits/#comportamento-dos-metodos","title":"Comportamento dos m\u00e9todos","text":"<p>Os m\u00e9todos de leitura tipada:</p> <ul> <li>Retornam o valor convertido em caso de sucesso</li> <li>Retornam <code>None</code> em caso de falha</li> <li>Realizam reconex\u00e3o autom\u00e1tica</li> <li>Aplicam backoff exponencial</li> <li>Registram logs detalhados</li> </ul>"},{"location":"examples/read_floats32bits/#observacoes-importantes","title":"Observa\u00e7\u00f5es importantes","text":"<ul> <li>O endere\u00e7amento \u00e9 zero-based</li> <li>Confirme o tipo FLOAT configurado no dispositivo</li> <li>Utilize sempre o endianness correto</li> <li>Sempre valide o retorno antes de utilizar o valor</li> </ul>"},{"location":"examples/read_floats32bits/#encerrando-a-conexao","title":"Encerrando a conex\u00e3o","text":"<p>Ap\u00f3s finalizar a leitura, a conex\u00e3o pode ser encerrada explicitamente:</p> <pre><code>client.close()\n</code></pre>"},{"location":"examples/read_floats64bits/","title":"Leitura de Ponto Flutuante de 64 Bits","text":""},{"location":"examples/read_floats64bits/#exemplo-leitura-de-ponto-flutuante-de-64-bits-float64","title":"Exemplo \u2013 Leitura de Ponto Flutuante de 64 Bits (FLOAT64)","text":"<p>Este exemplo demonstra como realizar a leitura de valores em ponto flutuante de 64 bits (FLOAT64) utilizando a biblioteca pyModbusTCPtools.</p> <p>Valores FLOAT64 ocupam quatro registradores Modbus consecutivos e representam n\u00fameros reais de dupla precis\u00e3o, conforme o padr\u00e3o IEEE 754.</p>"},{"location":"examples/read_floats64bits/#cenario-tipico","title":"Cen\u00e1rio t\u00edpico","text":"<ul> <li>Leitura de energia acumulada</li> <li>Leitura de totalizadores de alta precis\u00e3o</li> <li>Leitura de vari\u00e1veis de processo cr\u00edticas</li> <li>Monitoramento de grandezas com alta resolu\u00e7\u00e3o num\u00e9rica</li> </ul> <p>Neste exemplo, ser\u00e1 realizada a leitura a partir do Holding Register no endere\u00e7o 500.</p>"},{"location":"examples/read_floats64bits/#importacoes","title":"Importa\u00e7\u00f5es","text":"<pre><code>from pyModbusTCPtools import (\n    ModbusTCPResiliente,\n    ModbusDataType,\n    Endian\n)\n</code></pre>"},{"location":"examples/read_floats64bits/#criacao-do-cliente","title":"Cria\u00e7\u00e3o do cliente","text":"<pre><code>client = ModbusTCPResiliente(\n    host=\"192.168.0.10\",\n    unit_id=1,\n    timeout=3.0,\n    console=True\n)\n</code></pre>"},{"location":"examples/read_floats64bits/#leitura-de-float64","title":"Leitura de FLOAT64","text":"<pre><code>valor_float64 = client.read_holding_typed_safe(\n    addr=500,\n    dtype=ModbusDataType.FLOAT64,\n    endian=Endian.BE\n)\n\nif valor_float64 is not None:\n    print(f\"FLOAT64 lido: {valor_float64}\")\nelse:\n    print(\"Falha na leitura do FLOAT64\")\n</code></pre>"},{"location":"examples/read_floats64bits/#observacao-sobre-endianness","title":"Observa\u00e7\u00e3o sobre endianness","text":"<p>Valores FLOAT64 s\u00e3o altamente sens\u00edveis \u00e0 configura\u00e7\u00e3o de endianness.</p> <p>Caso o valor lido n\u00e3o seja coerente, teste outras op\u00e7\u00f5es:</p> <ul> <li><code>Endian.LE</code></li> <li><code>Endian.BE_SWAP</code></li> <li><code>Endian.LE_SWAP</code></li> </ul> <p>A biblioteca n\u00e3o tenta inferir automaticamente o endianness correto.</p>"},{"location":"examples/read_floats64bits/#caracteristicas-do-float64","title":"Caracter\u00edsticas do FLOAT64","text":"<ul> <li>Padr\u00e3o IEEE 754 (dupla precis\u00e3o)</li> <li>64 bits de largura</li> <li>Ocupa 4 registradores Modbus</li> <li>Alta precis\u00e3o para c\u00e1lculos industriais</li> </ul>"},{"location":"examples/read_floats64bits/#comportamento-dos-metodos","title":"Comportamento dos m\u00e9todos","text":"<p>Os m\u00e9todos de leitura tipada:</p> <ul> <li>Retornam o valor convertido em caso de sucesso</li> <li>Retornam <code>None</code> em caso de falha</li> <li>Realizam reconex\u00e3o autom\u00e1tica</li> <li>Aplicam backoff exponencial</li> <li>Registram logs detalhados</li> </ul>"},{"location":"examples/read_floats64bits/#observacoes-importantes","title":"Observa\u00e7\u00f5es importantes","text":"<ul> <li>O endere\u00e7amento \u00e9 zero-based</li> <li>Confirme se o dispositivo suporta FLOAT64</li> <li>Utilize sempre o endianness correto</li> <li>Valores incoerentes geralmente indicam erro de endianness</li> <li>Sempre valide o retorno antes de utilizar o valor</li> </ul>"},{"location":"examples/read_floats64bits/#encerrando-a-conexao","title":"Encerrando a conex\u00e3o","text":"<p>Ap\u00f3s finalizar a leitura, a conex\u00e3o pode ser encerrada explicitamente:</p> <pre><code>client.close()\n</code></pre>"},{"location":"examples/read_integers16bits/","title":"Leitura de Inteiros de 16 Bits","text":""},{"location":"examples/read_integers16bits/#exemplo-leitura-de-inteiros-de-16-bits","title":"Exemplo \u2013 Leitura de Inteiros de 16 Bits","text":"<p>Este exemplo demonstra como realizar a leitura de valores inteiros de 16 bits utilizando a biblioteca pyModbusTCPtools, contemplando valores sem sinal (UINT16) e valores com sinal (INT16).</p> <p>A leitura de inteiros de 16 bits \u00e9 comum em aplica\u00e7\u00f5es industriais para leitura de contadores, estados codificados e vari\u00e1veis anal\u00f3gicas simples.</p>"},{"location":"examples/read_integers16bits/#cenario-tipico","title":"Cen\u00e1rio t\u00edpico","text":"<ul> <li>Leitura de contadores</li> <li>Leitura de estados codificados em registradores</li> <li>Leitura de valores anal\u00f3gicos inteiros</li> <li>Monitoramento de vari\u00e1veis internas de CLPs</li> </ul> <p>Neste exemplo, ser\u00e1 realizada a leitura a partir do Holding Register no endere\u00e7o 100.</p>"},{"location":"examples/read_integers16bits/#importacoes","title":"Importa\u00e7\u00f5es","text":"<pre><code>from pyModbusTCPtools import (\n    ModbusTCPResiliente,\n    ModbusDataType\n)\n</code></pre>"},{"location":"examples/read_integers16bits/#criacao-do-cliente","title":"Cria\u00e7\u00e3o do cliente","text":"<pre><code>client = ModbusTCPResiliente(\n    host=\"192.168.0.10\",\n    unit_id=1,\n    timeout=3.0,\n    console=True\n)\n</code></pre>"},{"location":"examples/read_integers16bits/#leitura-de-inteiro-de-16-bits-sem-sinal-uint16","title":"Leitura de inteiro de 16 bits sem sinal (UINT16)","text":"<pre><code>valor_uint16 = client.read_holding_typed_safe(\n    addr=100,\n    dtype=ModbusDataType.UINT16\n)\n\nif valor_uint16 is not None:\n    print(f\"UINT16 lido: {valor_uint16}\")\nelse:\n    print(\"Falha na leitura do UINT16\")\n</code></pre>"},{"location":"examples/read_integers16bits/#leitura-de-inteiro-de-16-bits-com-sinal-int16","title":"Leitura de inteiro de 16 bits com sinal (INT16)","text":"<pre><code>valor_int16 = client.read_holding_typed_safe(\n    addr=101,\n    dtype=ModbusDataType.INT16\n)\n\nif valor_int16 is not None:\n    print(f\"INT16 lido: {valor_int16}\")\nelse:\n    print(\"Falha na leitura do INT16\")\n</code></pre>"},{"location":"examples/read_integers16bits/#diferenca-entre-int16-e-uint16","title":"Diferen\u00e7a entre INT16 e UINT16","text":"<ul> <li><code>UINT16</code> representa valores no intervalo de 0 a 65535</li> <li><code>INT16</code> representa valores no intervalo de -32768 a 32767</li> <li>A convers\u00e3o \u00e9 realizada automaticamente pela biblioteca</li> <li>Nenhuma manipula\u00e7\u00e3o manual de bits \u00e9 necess\u00e1ria</li> </ul>"},{"location":"examples/read_integers16bits/#comportamento-dos-metodos","title":"Comportamento dos m\u00e9todos","text":"<p>Os m\u00e9todos de leitura tipada possuem o seguinte comportamento:</p> <ul> <li>Retornam o valor convertido em caso de sucesso</li> <li>Retornam <code>None</code> em caso de falha</li> <li>Realizam reconex\u00e3o autom\u00e1tica se necess\u00e1rio</li> <li>Aplicam backoff exponencial em falhas consecutivas</li> <li>Registram logs detalhados</li> </ul>"},{"location":"examples/read_integers16bits/#observacoes-importantes","title":"Observa\u00e7\u00f5es importantes","text":"<ul> <li>O endere\u00e7amento \u00e9 zero-based</li> <li>Certifique-se do tipo correto configurado no dispositivo Modbus</li> <li>N\u00e3o confunda valores com e sem sinal</li> <li>Sempre valide o retorno antes de utilizar o valor</li> </ul>"},{"location":"examples/read_integers16bits/#encerrando-a-conexao","title":"Encerrando a conex\u00e3o","text":"<p>Ap\u00f3s finalizar as leituras, a conex\u00e3o pode ser encerrada explicitamente:</p> <pre><code>client.close()\n</code></pre>"},{"location":"examples/read_integers32bits/","title":"Leitura de Inteiros de 32 Bits","text":""},{"location":"examples/read_integers32bits/#exemplo-leitura-de-inteiros-de-32-bits","title":"Exemplo \u2013 Leitura de Inteiros de 32 Bits","text":"<p>Este exemplo demonstra como realizar a leitura de valores inteiros de 32 bits utilizando a biblioteca pyModbusTCPtools, contemplando valores sem sinal (UINT32) e valores com sinal (INT32).</p> <p>Valores de 32 bits ocupam dois registradores Modbus consecutivos e podem exigir aten\u00e7\u00e3o especial ao endianness configurado no dispositivo.</p>"},{"location":"examples/read_integers32bits/#cenario-tipico","title":"Cen\u00e1rio t\u00edpico","text":"<ul> <li>Leitura de contadores de alta resolu\u00e7\u00e3o</li> <li>Leitura de valores acumulados</li> <li>Leitura de vari\u00e1veis internas de CLPs</li> <li>Monitoramento de grandezas que excedem 16 bits</li> </ul> <p>Neste exemplo, ser\u00e1 realizada a leitura a partir do Holding Register no endere\u00e7o 200.</p>"},{"location":"examples/read_integers32bits/#importacoes","title":"Importa\u00e7\u00f5es","text":"<pre><code>from pyModbusTCPtools import (\n    ModbusTCPResiliente,\n    ModbusDataType,\n    Endian\n)\n</code></pre>"},{"location":"examples/read_integers32bits/#criacao-do-cliente","title":"Cria\u00e7\u00e3o do cliente","text":"<pre><code>client = ModbusTCPResiliente(\n    host=\"192.168.0.10\",\n    unit_id=1,\n    timeout=3.0,\n    console=True\n)\n</code></pre>"},{"location":"examples/read_integers32bits/#leitura-de-inteiro-de-32-bits-sem-sinal-uint32","title":"Leitura de inteiro de 32 bits sem sinal (UINT32)","text":"<pre><code>valor_uint32 = client.read_holding_typed_safe(\n    addr=200,\n    dtype=ModbusDataType.UINT32,\n    endian=Endian.BE\n)\n\nif valor_uint32 is not None:\n    print(f\"UINT32 lido: {valor_uint32}\")\nelse:\n    print(\"Falha na leitura do UINT32\")\n</code></pre>"},{"location":"examples/read_integers32bits/#leitura-de-inteiro-de-32-bits-com-sinal-int32","title":"Leitura de inteiro de 32 bits com sinal (INT32)","text":"<pre><code>valor_int32 = client.read_holding_typed_safe(\n    addr=202,\n    dtype=ModbusDataType.INT32,\n    endian=Endian.BE\n)\n\nif valor_int32 is not None:\n    print(f\"INT32 lido: {valor_int32}\")\nelse:\n    print(\"Falha na leitura do INT32\")\n</code></pre>"},{"location":"examples/read_integers32bits/#observacao-sobre-endianness","title":"Observa\u00e7\u00e3o sobre endianness","text":"<p>Valores de 32 bits podem ser organizados de diferentes formas dependendo do fabricante.</p> <p>Caso os valores lidos estejam incorretos, teste outras op\u00e7\u00f5es:</p> <ul> <li><code>Endian.LE</code></li> <li><code>Endian.BE_SWAP</code></li> <li><code>Endian.LE_SWAP</code></li> </ul> <p>A biblioteca n\u00e3o tenta inferir automaticamente o endianness correto.</p>"},{"location":"examples/read_integers32bits/#diferenca-entre-int32-e-uint32","title":"Diferen\u00e7a entre INT32 e UINT32","text":"<ul> <li><code>UINT32</code> representa valores no intervalo de 0 a 4.294.967.295</li> <li><code>INT32</code> representa valores no intervalo de -2.147.483.648 a 2.147.483.647</li> <li>Ambos ocupam 2 registradores Modbus</li> <li>A convers\u00e3o \u00e9 feita automaticamente</li> </ul>"},{"location":"examples/read_integers32bits/#comportamento-dos-metodos","title":"Comportamento dos m\u00e9todos","text":"<p>Os m\u00e9todos de leitura tipada:</p> <ul> <li>Retornam o valor convertido em caso de sucesso</li> <li>Retornam <code>None</code> em caso de falha</li> <li>Realizam reconex\u00e3o autom\u00e1tica</li> <li>Aplicam backoff exponencial</li> <li>Registram logs detalhados</li> </ul>"},{"location":"examples/read_integers32bits/#observacoes-importantes","title":"Observa\u00e7\u00f5es importantes","text":"<ul> <li>O endere\u00e7amento \u00e9 zero-based</li> <li>Utilize sempre o endianness correto</li> <li>N\u00e3o misture tipos com e sem sinal</li> <li>Sempre valide o retorno antes de utilizar o valor</li> </ul>"},{"location":"examples/read_integers32bits/#encerrando-a-conexao","title":"Encerrando a conex\u00e3o","text":"<p>Ap\u00f3s finalizar as leituras, a conex\u00e3o pode ser encerrada explicitamente:</p> <pre><code>client.close()\n</code></pre>"},{"location":"examples/read_integers64bits/","title":"Leitura de Inteiros de 64 Bits","text":""},{"location":"examples/read_integers64bits/#exemplo-leitura-de-inteiros-de-64-bits","title":"Exemplo \u2013 Leitura de Inteiros de 64 Bits","text":"<p>Este exemplo demonstra como realizar a leitura de valores inteiros de 64 bits utilizando a biblioteca pyModbusTCPtools, contemplando valores sem sinal (UINT64) e valores com sinal (INT64).</p> <p>Valores de 64 bits ocupam quatro registradores Modbus consecutivos e exigem aten\u00e7\u00e3o especial ao endianness configurado no dispositivo.</p>"},{"location":"examples/read_integers64bits/#cenario-tipico","title":"Cen\u00e1rio t\u00edpico","text":"<ul> <li>Leitura de contadores de grande capacidade</li> <li>Leitura de acumuladores de energia ou produ\u00e7\u00e3o</li> <li>Leitura de identificadores num\u00e9ricos extensos</li> <li>Monitoramento de vari\u00e1veis de alta resolu\u00e7\u00e3o</li> </ul> <p>Neste exemplo, ser\u00e1 realizada a leitura a partir do Holding Register no endere\u00e7o 300.</p>"},{"location":"examples/read_integers64bits/#importacoes","title":"Importa\u00e7\u00f5es","text":"<pre><code>from pyModbusTCPtools import (\n    ModbusTCPResiliente,\n    ModbusDataType,\n    Endian\n)\n</code></pre>"},{"location":"examples/read_integers64bits/#criacao-do-cliente","title":"Cria\u00e7\u00e3o do cliente","text":"<pre><code>client = ModbusTCPResiliente(\n    host=\"192.168.0.10\",\n    unit_id=1,\n    timeout=3.0,\n    console=True\n)\n</code></pre>"},{"location":"examples/read_integers64bits/#leitura-de-inteiro-de-64-bits-sem-sinal-uint64","title":"Leitura de inteiro de 64 bits sem sinal (UINT64)","text":"<pre><code>valor_uint64 = client.read_holding_typed_safe(\n    addr=300,\n    dtype=ModbusDataType.UINT64,\n    endian=Endian.BE\n)\n\nif valor_uint64 is not None:\n    print(f\"UINT64 lido: {valor_uint64}\")\nelse:\n    print(\"Falha na leitura do UINT64\")\n</code></pre>"},{"location":"examples/read_integers64bits/#leitura-de-inteiro-de-64-bits-com-sinal-int64","title":"Leitura de inteiro de 64 bits com sinal (INT64)","text":"<pre><code>valor_int64 = client.read_holding_typed_safe(\n    addr=304,\n    dtype=ModbusDataType.INT64,\n    endian=Endian.BE\n)\n\nif valor_int64 is not None:\n    print(f\"INT64 lido: {valor_int64}\")\nelse:\n    print(\"Falha na leitura do INT64\")\n</code></pre>"},{"location":"examples/read_integers64bits/#observacao-sobre-endianness","title":"Observa\u00e7\u00e3o sobre endianness","text":"<p>Valores de 64 bits podem ser organizados de diferentes formas dependendo do fabricante.</p> <p>Caso os valores lidos estejam incorretos, teste outras op\u00e7\u00f5es:</p> <ul> <li><code>Endian.LE</code></li> <li><code>Endian.BE_SWAP</code></li> <li><code>Endian.LE_SWAP</code></li> </ul> <p>A biblioteca n\u00e3o tenta inferir automaticamente o endianness correto.</p>"},{"location":"examples/read_integers64bits/#diferenca-entre-int64-e-uint64","title":"Diferen\u00e7a entre INT64 e UINT64","text":"<ul> <li><code>UINT64</code> representa valores no intervalo de 0 a 18.446.744.073.709.551.615</li> <li><code>INT64</code> representa valores no intervalo de -9.223.372.036.854.775.808 a 9.223.372.036.854.775.807</li> <li>Ambos ocupam 4 registradores Modbus</li> <li>A convers\u00e3o \u00e9 realizada automaticamente pela biblioteca</li> </ul>"},{"location":"examples/read_integers64bits/#comportamento-dos-metodos","title":"Comportamento dos m\u00e9todos","text":"<p>Os m\u00e9todos de leitura tipada:</p> <ul> <li>Retornam o valor convertido em caso de sucesso</li> <li>Retornam <code>None</code> em caso de falha</li> <li>Realizam reconex\u00e3o autom\u00e1tica</li> <li>Aplicam backoff exponencial</li> <li>Registram logs detalhados</li> </ul>"},{"location":"examples/read_integers64bits/#observacoes-importantes","title":"Observa\u00e7\u00f5es importantes","text":"<ul> <li>O endere\u00e7amento \u00e9 zero-based</li> <li>Utilize sempre o endianness correto</li> <li>Valores de 64 bits exigem aten\u00e7\u00e3o redobrada ao endere\u00e7o inicial</li> <li>Sempre valide o retorno antes de utilizar o valor</li> </ul>"},{"location":"examples/read_integers64bits/#encerrando-a-conexao","title":"Encerrando a conex\u00e3o","text":"<p>Ap\u00f3s finalizar as leituras, a conex\u00e3o pode ser encerrada explicitamente:</p> <pre><code>client.close()\n</code></pre>"},{"location":"examples/reconnection/","title":"Reconex\u00e3o","text":""},{"location":"examples/reconnection/#exemplo-reconexao-automatica","title":"Exemplo \u2013 Reconex\u00e3o Autom\u00e1tica","text":"<p>Este exemplo demonstra como a biblioteca pyModbusTCPtools realiza reconex\u00e3o autom\u00e1tica em caso de falhas de comunica\u00e7\u00e3o Modbus TCP.</p> <p>Em ambientes industriais, quedas de rede, reinicializa\u00e7\u00e3o de CLPs e perda tempor\u00e1ria de conex\u00e3o s\u00e3o eventos normais. A biblioteca foi projetada para lidar com essas situa\u00e7\u00f5es de forma transparente.</p>"},{"location":"examples/reconnection/#cenario-tipico","title":"Cen\u00e1rio t\u00edpico","text":"<ul> <li>CLP reiniciado durante a opera\u00e7\u00e3o</li> <li>Perda tempor\u00e1ria de conex\u00e3o de rede</li> <li>Timeout de comunica\u00e7\u00e3o</li> <li>Falhas intermitentes em switches ou cabos</li> </ul> <p>Neste exemplo, ser\u00e1 demonstrado como a reconex\u00e3o ocorre automaticamente durante leituras cont\u00ednuas.</p>"},{"location":"examples/reconnection/#importacoes","title":"Importa\u00e7\u00f5es","text":"<pre><code>from time import sleep\nfrom pyModbusTCPtools import (\n    ModbusTCPResiliente,\n    ModbusDataType\n)\n</code></pre>"},{"location":"examples/reconnection/#criacao-do-cliente-com-reconexao-habilitada","title":"Cria\u00e7\u00e3o do cliente com reconex\u00e3o habilitada","text":"<pre><code>client = ModbusTCPResiliente(\n    host=\"192.168.0.10\",\n    unit_id=1,\n    timeout=3.0,\n    retry_delay=2.0,\n    max_retry_delay=30.0,\n    console=True\n)\n</code></pre> <p>Os par\u00e2metros <code>retry_delay</code> e <code>max_retry_delay</code> controlam o backoff exponencial entre tentativas de reconex\u00e3o.</p>"},{"location":"examples/reconnection/#leitura-continua-com-reconexao-automatica","title":"Leitura cont\u00ednua com reconex\u00e3o autom\u00e1tica","text":"<pre><code>while True:\n    valor = client.read_holding_typed_safe(\n        addr=100,\n        dtype=ModbusDataType.INT16\n    )\n\n    if valor is not None:\n        print(f\"Valor lido: {valor}\")\n    else:\n        print(\"Falha de comunica\u00e7\u00e3o. Tentando reconectar...\")\n\n    sleep(2)\n</code></pre> <p>Neste loop:</p> <ul> <li>Falhas de comunica\u00e7\u00e3o n\u00e3o encerram o programa</li> <li>A biblioteca tenta reconectar automaticamente</li> <li>O tempo entre tentativas aumenta progressivamente</li> <li>Leituras bem-sucedidas retomam automaticamente</li> </ul>"},{"location":"examples/reconnection/#verificacao-explicita-de-conexao","title":"Verifica\u00e7\u00e3o expl\u00edcita de conex\u00e3o","text":"<p>Tamb\u00e9m \u00e9 poss\u00edvel verificar explicitamente o estado da conex\u00e3o:</p> <pre><code>if client.is_connected():\n    print(\"Conex\u00e3o ativa\")\nelse:\n    print(\"Conex\u00e3o indispon\u00edvel\")\n</code></pre> <p>O m\u00e9todo <code>is_connected</code> realiza uma leitura real para validar a comunica\u00e7\u00e3o.</p>"},{"location":"examples/reconnection/#comportamento-da-reconexao","title":"Comportamento da reconex\u00e3o","text":"<p>O mecanismo de reconex\u00e3o segue as seguintes regras:</p> <ul> <li>Reconex\u00e3o autom\u00e1tica em falhas de socket ou timeout</li> <li>Backoff exponencial configur\u00e1vel</li> <li>Limite m\u00e1ximo de atraso entre tentativas</li> <li>Logs detalhados de cada tentativa</li> <li>Retomada autom\u00e1tica ap\u00f3s restabelecimento da comunica\u00e7\u00e3o</li> </ul> <p>Nenhuma a\u00e7\u00e3o manual \u00e9 necess\u00e1ria para reconectar.</p>"},{"location":"examples/reconnection/#observacoes-importantes","title":"Observa\u00e7\u00f5es importantes","text":"<ul> <li>Falhas de comunica\u00e7\u00e3o s\u00e3o tratadas como eventos normais</li> <li>Evite loops muito r\u00e1pidos sem <code>sleep</code></li> <li>Utilize logs para diagn\u00f3stico em produ\u00e7\u00e3o</li> <li>N\u00e3o finalize a aplica\u00e7\u00e3o em falhas transit\u00f3rias</li> </ul>"},{"location":"examples/reconnection/#encerrando-a-conexao","title":"Encerrando a conex\u00e3o","text":"<p>Quando a aplica\u00e7\u00e3o for encerrada, a conex\u00e3o pode ser fechada explicitamente:</p> <pre><code>client.close()\n</code></pre>"},{"location":"examples/reconnection/#conclusao","title":"Conclus\u00e3o","text":"<p>O mecanismo de reconex\u00e3o autom\u00e1tica da pyModbusTCPtools permite criar aplica\u00e7\u00f5es Modbus TCP robustas e resilientes, adequadas para opera\u00e7\u00e3o cont\u00ednua em ambientes industriais reais.</p>"},{"location":"examples/write_coils/","title":"Escrita de Coils","text":""},{"location":"examples/write_coils/#exemplo-escrita-de-coils","title":"Exemplo \u2013 Escrita de Coils","text":"<p>Este exemplo demonstra como realizar a escrita de coils (valores booleanos) utilizando a biblioteca pyModbusTCPtools de forma segura.</p> <p>A escrita de coils \u00e9 normalmente utilizada para acionar comandos digitais, como ligar/desligar motores, v\u00e1lvulas, rel\u00e9s ou flags internas de controle.</p>"},{"location":"examples/write_coils/#cenario-tipico","title":"Cen\u00e1rio t\u00edpico","text":"<ul> <li>Acionamento de uma sa\u00edda digital</li> <li>Envio de comando liga/desliga</li> <li>Escrita de flags de controle em CLPs e dispositivos Modbus TCP</li> </ul> <p>Neste exemplo, ser\u00e1 realizada a escrita da coil no endere\u00e7o 0.</p>"},{"location":"examples/write_coils/#importacoes","title":"Importa\u00e7\u00f5es","text":"<pre><code>from pyModbusTCPtools import ModbusTCPResiliente\n</code></pre>"},{"location":"examples/write_coils/#criacao-do-cliente","title":"Cria\u00e7\u00e3o do cliente","text":"<pre><code>client = ModbusTCPResiliente(\n    host=\"192.168.0.10\",\n    unit_id=1,\n    timeout=3.0,\n    console=True\n)\n</code></pre>"},{"location":"examples/write_coils/#escrita-de-uma-coil","title":"Escrita de uma coil","text":""},{"location":"examples/write_coils/#escrita-de-valor-true","title":"Escrita de valor <code>True</code>","text":"<pre><code>ok = client.write_single_coil_safe(addr=0, value=True)\n\nif ok:\n    print(\"Coil 0 escrita com sucesso (True)\")\nelse:\n    print(\"Falha ao escrever a coil 0\")\n</code></pre>"},{"location":"examples/write_coils/#escrita-de-valor-false","title":"Escrita de valor <code>False</code>","text":"<pre><code>ok = client.write_single_coil_safe(addr=0, value=False)\n\nif ok:\n    print(\"Coil 0 escrita com sucesso (False)\")\nelse:\n    print(\"Falha ao escrever a coil 0\")\n</code></pre>"},{"location":"examples/write_coils/#escrita-de-multiplas-coils","title":"Escrita de m\u00faltiplas coils","text":"<p>Tamb\u00e9m \u00e9 poss\u00edvel escrever v\u00e1rias coils em uma \u00fanica opera\u00e7\u00e3o.</p> <pre><code>values = [True, False, True, True]\n\nok = client.write_multiple_coils_safe(addr=10, values=values)\n\nif ok:\n    print(\"M\u00faltiplas coils escritas com sucesso\")\nelse:\n    print(\"Falha na escrita das coils\")\n</code></pre>"},{"location":"examples/write_coils/#comportamento-dos-metodos","title":"Comportamento dos m\u00e9todos","text":"<p>Os m\u00e9todos de escrita de coils possuem o seguinte comportamento:</p> <ul> <li>Retornam <code>True</code> em caso de sucesso</li> <li>Retornam <code>False</code> em caso de falha</li> <li>Realizam reconex\u00e3o autom\u00e1tica se necess\u00e1rio</li> <li>Aplicam backoff exponencial em falhas consecutivas</li> <li>Registram logs detalhados</li> </ul>"},{"location":"examples/write_coils/#observacoes-importantes","title":"Observa\u00e7\u00f5es importantes","text":"<ul> <li>O endere\u00e7amento \u00e9 zero-based</li> <li>Sempre verifique o retorno do m\u00e9todo</li> <li>N\u00e3o assuma que o endere\u00e7o da coil existe no dispositivo</li> <li>Em sistemas industriais, comandos devem ser escritos com valida\u00e7\u00e3o adicional</li> </ul>"},{"location":"examples/write_coils/#encerrando-a-conexao","title":"Encerrando a conex\u00e3o","text":"<p>Ap\u00f3s finalizar as opera\u00e7\u00f5es, a conex\u00e3o pode ser encerrada explicitamente:</p> <pre><code>client.close()\n</code></pre>"},{"location":"examples/write_floats32bits/","title":"Escrita de Ponto Flutuante de 32 Bits","text":""},{"location":"examples/write_floats32bits/#exemplo-escrita-de-ponto-flutuante-de-32-bits-float32","title":"Exemplo \u2013 Escrita de Ponto Flutuante de 32 Bits (FLOAT32)","text":"<p>Este exemplo demonstra como realizar a escrita de valores em ponto flutuante de 32 bits (FLOAT32) utilizando a biblioteca pyModbusTCPtools.</p> <p>Valores FLOAT32 ocupam dois registradores Modbus consecutivos e seguem o padr\u00e3o IEEE 754, exigindo aten\u00e7\u00e3o ao endianness configurado no dispositivo.</p>"},{"location":"examples/write_floats32bits/#cenario-tipico","title":"Cen\u00e1rio t\u00edpico","text":"<ul> <li>Escrita de setpoints anal\u00f3gicos</li> <li>Ajuste de par\u00e2metros de processo</li> <li>Configura\u00e7\u00e3o de valores de engenharia</li> <li>Envio de refer\u00eancias em ponto flutuante</li> </ul> <p>Neste exemplo, ser\u00e1 realizada a escrita em Holding Registers a partir do endere\u00e7o 900.</p>"},{"location":"examples/write_floats32bits/#importacoes","title":"Importa\u00e7\u00f5es","text":"<pre><code>from pyModbusTCPtools import (\n    ModbusTCPResiliente,\n    ModbusDataType,\n    Endian\n)\n</code></pre>"},{"location":"examples/write_floats32bits/#criacao-do-cliente","title":"Cria\u00e7\u00e3o do cliente","text":"<pre><code>client = ModbusTCPResiliente(\n    host=\"192.168.0.10\",\n    unit_id=1,\n    timeout=3.0,\n    console=True\n)\n</code></pre>"},{"location":"examples/write_floats32bits/#escrita-de-float32","title":"Escrita de FLOAT32","text":"<pre><code>ok = client.write_holding_typed_safe(\n    addr=900,\n    value=12.75,\n    dtype=ModbusDataType.FLOAT32,\n    endian=Endian.BE\n)\n\nif ok:\n    print(\"FLOAT32 escrito com sucesso\")\nelse:\n    print(\"Falha na escrita do FLOAT32\")\n</code></pre>"},{"location":"examples/write_floats32bits/#observacao-sobre-endianness","title":"Observa\u00e7\u00e3o sobre endianness","text":"<p>Valores FLOAT32 s\u00e3o altamente dependentes da configura\u00e7\u00e3o correta de endianness.</p> <p>Caso o valor n\u00e3o seja interpretado corretamente pelo dispositivo, teste:</p> <ul> <li><code>Endian.LE</code></li> <li><code>Endian.BE_SWAP</code></li> <li><code>Endian.LE_SWAP</code></li> </ul> <p>A biblioteca n\u00e3o tenta inferir automaticamente o endianness correto.</p>"},{"location":"examples/write_floats32bits/#caracteristicas-do-float32","title":"Caracter\u00edsticas do FLOAT32","text":"<ul> <li>Padr\u00e3o IEEE 754</li> <li>32 bits de largura</li> <li>Ocupa 2 registradores Modbus</li> <li>Representa n\u00fameros reais com casas decimais</li> </ul>"},{"location":"examples/write_floats32bits/#comportamento-dos-metodos","title":"Comportamento dos m\u00e9todos","text":"<p>Os m\u00e9todos de escrita tipada:</p> <ul> <li>Retornam <code>True</code> em caso de sucesso</li> <li>Retornam <code>False</code> em caso de falha</li> <li>Validam tipo e faixa do valor</li> <li>Realizam reconex\u00e3o autom\u00e1tica se necess\u00e1rio</li> <li>Aplicam backoff exponencial</li> <li>Registram logs detalhados</li> </ul>"},{"location":"examples/write_floats32bits/#observacoes-importantes","title":"Observa\u00e7\u00f5es importantes","text":"<ul> <li>O endere\u00e7amento \u00e9 zero-based</li> <li>Confirme o suporte a FLOAT32 no dispositivo</li> <li>Utilize sempre o endianness correto</li> <li>Valores inv\u00e1lidos resultam em erro de convers\u00e3o</li> <li>Sempre verifique o retorno do m\u00e9todo</li> </ul>"},{"location":"examples/write_floats32bits/#encerrando-a-conexao","title":"Encerrando a conex\u00e3o","text":"<p>Ap\u00f3s finalizar a escrita, a conex\u00e3o pode ser encerrada explicitamente:</p> <pre><code>client.close()\n</code></pre>"},{"location":"examples/write_floats32bits/#proximo-passo","title":"Pr\u00f3ximo passo","text":"<p>Ap\u00f3s compreender a escrita de FLOAT32, avance para o exemplo de escrita de ponto flutuante de 64 bits (FLOAT64).</p>"},{"location":"examples/write_floats64bits/","title":"Escrita de Ponto Flutuante de 64 Bits","text":""},{"location":"examples/write_floats64bits/#exemplo-escrita-de-ponto-flutuante-de-64-bits-float64","title":"Exemplo \u2013 Escrita de Ponto Flutuante de 64 Bits (FLOAT64)","text":"<p>Este exemplo demonstra como realizar a escrita de valores em ponto flutuante de 64 bits (FLOAT64) utilizando a biblioteca pyModbusTCPtools.</p> <p>Valores FLOAT64 ocupam quatro registradores Modbus consecutivos e seguem o padr\u00e3o IEEE 754 (dupla precis\u00e3o), exigindo aten\u00e7\u00e3o rigorosa ao endianness configurado no dispositivo.</p>"},{"location":"examples/write_floats64bits/#cenario-tipico","title":"Cen\u00e1rio t\u00edpico","text":"<ul> <li>Escrita de totalizadores de alta precis\u00e3o</li> <li>Configura\u00e7\u00e3o de par\u00e2metros cr\u00edticos de processo</li> <li>Envio de valores de engenharia de dupla precis\u00e3o</li> <li>Ajuste fino de vari\u00e1veis industriais</li> </ul> <p>Neste exemplo, ser\u00e1 realizada a escrita em Holding Registers a partir do endere\u00e7o 1000.</p>"},{"location":"examples/write_floats64bits/#importacoes","title":"Importa\u00e7\u00f5es","text":"<pre><code>from pyModbusTCPtools import (\n    ModbusTCPResiliente,\n    ModbusDataType,\n    Endian\n)\n</code></pre>"},{"location":"examples/write_floats64bits/#criacao-do-cliente","title":"Cria\u00e7\u00e3o do cliente","text":"<pre><code>client = ModbusTCPResiliente(\n    host=\"192.168.0.10\",\n    unit_id=1,\n    timeout=3.0,\n    console=True\n)\n</code></pre>"},{"location":"examples/write_floats64bits/#escrita-de-float64","title":"Escrita de FLOAT64","text":"<pre><code>ok = client.write_holding_typed_safe(\n    addr=1000,\n    value=12345.6789,\n    dtype=ModbusDataType.FLOAT64,\n    endian=Endian.BE\n)\n\nif ok:\n    print(\"FLOAT64 escrito com sucesso\")\nelse:\n    print(\"Falha na escrita do FLOAT64\")\n</code></pre>"},{"location":"examples/write_floats64bits/#observacao-sobre-endianness","title":"Observa\u00e7\u00e3o sobre endianness","text":"<p>Valores FLOAT64 s\u00e3o extremamente sens\u00edveis \u00e0 configura\u00e7\u00e3o correta de endianness.</p> <p>Caso o valor escrito n\u00e3o seja interpretado corretamente pelo dispositivo, teste:</p> <ul> <li><code>Endian.LE</code></li> <li><code>Endian.BE_SWAP</code></li> <li><code>Endian.LE_SWAP</code></li> </ul> <p>A biblioteca n\u00e3o tenta inferir automaticamente o endianness correto.</p>"},{"location":"examples/write_floats64bits/#caracteristicas-do-float64","title":"Caracter\u00edsticas do FLOAT64","text":"<ul> <li>Padr\u00e3o IEEE 754 (dupla precis\u00e3o)</li> <li>64 bits de largura</li> <li>Ocupa 4 registradores Modbus</li> <li>Alta precis\u00e3o num\u00e9rica para aplica\u00e7\u00f5es industriais</li> </ul>"},{"location":"examples/write_floats64bits/#comportamento-dos-metodos","title":"Comportamento dos m\u00e9todos","text":"<p>Os m\u00e9todos de escrita tipada:</p> <ul> <li>Retornam <code>True</code> em caso de sucesso</li> <li>Retornam <code>False</code> em caso de falha</li> <li>Validam tipo e faixa do valor</li> <li>Realizam reconex\u00e3o autom\u00e1tica se necess\u00e1rio</li> <li>Aplicam backoff exponencial</li> <li>Registram logs detalhados</li> </ul>"},{"location":"examples/write_floats64bits/#observacoes-importantes","title":"Observa\u00e7\u00f5es importantes","text":"<ul> <li>O endere\u00e7amento \u00e9 zero-based</li> <li>Confirme se o dispositivo suporta FLOAT64</li> <li>Utilize sempre o endianness correto</li> <li>Valores incoerentes normalmente indicam erro de endianness</li> <li>Sempre verifique o retorno do m\u00e9todo</li> </ul>"},{"location":"examples/write_floats64bits/#encerrando-a-conexao","title":"Encerrando a conex\u00e3o","text":"<p>Ap\u00f3s finalizar a escrita, a conex\u00e3o pode ser encerrada explicitamente:</p> <pre><code>client.close()\n</code></pre>"},{"location":"examples/write_floats64bits/#proximo-passo","title":"Pr\u00f3ximo passo","text":"<p>Com este exemplo, a sequ\u00eancia de leitura e escrita tipada est\u00e1 completa.</p> <p>Recomenda-se agora revisar os exemplos, validar em ambiente real e integrar a biblioteca ao projeto final.</p>"},{"location":"examples/write_integers16bits/","title":"Escrita de Inteiros de 16 Bits","text":""},{"location":"examples/write_integers16bits/#exemplo-escrita-de-inteiros-de-16-bits","title":"Exemplo \u2013 Escrita de Inteiros de 16 Bits","text":"<p>Este exemplo demonstra como realizar a escrita de valores inteiros de 16 bits utilizando a biblioteca pyModbusTCPtools, contemplando valores sem sinal (UINT16) e valores com sinal (INT16).</p> <p>A escrita de inteiros de 16 bits \u00e9 comum em aplica\u00e7\u00f5es industriais para envio de setpoints, par\u00e2metros e comandos num\u00e9ricos simples.</p>"},{"location":"examples/write_integers16bits/#cenario-tipico","title":"Cen\u00e1rio t\u00edpico","text":"<ul> <li>Escrita de setpoints</li> <li>Escrita de par\u00e2metros de configura\u00e7\u00e3o</li> <li>Envio de comandos num\u00e9ricos inteiros</li> <li>Ajuste de vari\u00e1veis internas de CLPs</li> </ul> <p>Neste exemplo, ser\u00e1 realizada a escrita em Holding Registers a partir do endere\u00e7o 600.</p>"},{"location":"examples/write_integers16bits/#importacoes","title":"Importa\u00e7\u00f5es","text":"<pre><code>from pyModbusTCPtools import (\n    ModbusTCPResiliente,\n    ModbusDataType\n)\n</code></pre>"},{"location":"examples/write_integers16bits/#criacao-do-cliente","title":"Cria\u00e7\u00e3o do cliente","text":"<pre><code>client = ModbusTCPResiliente(\n    host=\"192.168.0.10\",\n    unit_id=1,\n    timeout=3.0,\n    console=True\n)\n</code></pre>"},{"location":"examples/write_integers16bits/#escrita-de-inteiro-de-16-bits-sem-sinal-uint16","title":"Escrita de inteiro de 16 bits sem sinal (UINT16)","text":"<pre><code>ok = client.write_holding_typed_safe(\n    addr=600,\n    value=12345,\n    dtype=ModbusDataType.UINT16\n)\n\nif ok:\n    print(\"UINT16 escrito com sucesso\")\nelse:\n    print(\"Falha na escrita do UINT16\")\n</code></pre>"},{"location":"examples/write_integers16bits/#escrita-de-inteiro-de-16-bits-com-sinal-int16","title":"Escrita de inteiro de 16 bits com sinal (INT16)","text":"<pre><code>ok = client.write_holding_typed_safe(\n    addr=601,\n    value=-1234,\n    dtype=ModbusDataType.INT16\n)\n\nif ok:\n    print(\"INT16 escrito com sucesso\")\nelse:\n    print(\"Falha na escrita do INT16\")\n</code></pre>"},{"location":"examples/write_integers16bits/#diferenca-entre-int16-e-uint16","title":"Diferen\u00e7a entre INT16 e UINT16","text":"<ul> <li><code>UINT16</code> aceita valores no intervalo de 0 a 65535</li> <li><code>INT16</code> aceita valores no intervalo de -32768 a 32767</li> <li>A biblioteca valida automaticamente o range</li> <li>Valores fora do range geram erro de convers\u00e3o</li> </ul>"},{"location":"examples/write_integers16bits/#comportamento-dos-metodos","title":"Comportamento dos m\u00e9todos","text":"<p>Os m\u00e9todos de escrita tipada:</p> <ul> <li>Retornam <code>True</code> em caso de sucesso</li> <li>Retornam <code>False</code> em caso de falha</li> <li>Validam tipo e faixa de valores</li> <li>Realizam reconex\u00e3o autom\u00e1tica se necess\u00e1rio</li> <li>Aplicam backoff exponencial</li> <li>Registram logs detalhados</li> </ul>"},{"location":"examples/write_integers16bits/#observacoes-importantes","title":"Observa\u00e7\u00f5es importantes","text":"<ul> <li>O endere\u00e7amento \u00e9 zero-based</li> <li>Utilize o tipo correto (com ou sem sinal)</li> <li>N\u00e3o escreva valores fora do range permitido</li> <li>Sempre verifique o retorno do m\u00e9todo</li> </ul>"},{"location":"examples/write_integers16bits/#encerrando-a-conexao","title":"Encerrando a conex\u00e3o","text":"<p>Ap\u00f3s finalizar as escritas, a conex\u00e3o pode ser encerrada explicitamente:</p> <pre><code>client.close()\n</code></pre>"},{"location":"examples/write_integers32bits/","title":"Exemplo \u2013 Escrita de Inteiros de 32 Bits","text":""},{"location":"examples/write_integers32bits/#exemplo-escrita-de-inteiros-de-32-bits","title":"Exemplo \u2013 Escrita de Inteiros de 32 Bits","text":"<p>Este exemplo demonstra como realizar a escrita de valores inteiros de 32 bits utilizando a biblioteca pyModbusTCPtools, contemplando valores sem sinal (UINT32) e valores com sinal (INT32).</p> <p>Valores de 32 bits ocupam dois registradores Modbus consecutivos, exigindo aten\u00e7\u00e3o ao endianness configurado no dispositivo.</p>"},{"location":"examples/write_integers32bits/#cenario-tipico","title":"Cen\u00e1rio t\u00edpico","text":"<ul> <li>Escrita de setpoints de alta resolu\u00e7\u00e3o</li> <li>Escrita de contadores acumulados</li> <li>Configura\u00e7\u00e3o de par\u00e2metros que excedem 16 bits</li> <li>Ajuste de vari\u00e1veis internas de CLPs</li> </ul> <p>Neste exemplo, ser\u00e1 realizada a escrita em Holding Registers a partir do endere\u00e7o 700.</p>"},{"location":"examples/write_integers32bits/#importacoes","title":"Importa\u00e7\u00f5es","text":"<pre><code>from pyModbusTCPtools import (\n    ModbusTCPResiliente,\n    ModbusDataType,\n    Endian\n)\n</code></pre>"},{"location":"examples/write_integers32bits/#criacao-do-cliente","title":"Cria\u00e7\u00e3o do cliente","text":"<pre><code>client = ModbusTCPResiliente(\n    host=\"192.168.0.10\",\n    unit_id=1,\n    timeout=3.0,\n    console=True\n)\n</code></pre>"},{"location":"examples/write_integers32bits/#escrita-de-inteiro-de-32-bits-sem-sinal-uint32","title":"Escrita de inteiro de 32 bits sem sinal (UINT32)","text":"<pre><code>ok = client.write_holding_typed_safe(\n    addr=700,\n    value=123456789,\n    dtype=ModbusDataType.UINT32,\n    endian=Endian.BE\n)\n\nif ok:\n    print(\"UINT32 escrito com sucesso\")\nelse:\n    print(\"Falha na escrita do UINT32\")\n</code></pre>"},{"location":"examples/write_integers32bits/#escrita-de-inteiro-de-32-bits-com-sinal-int32","title":"Escrita de inteiro de 32 bits com sinal (INT32)","text":"<pre><code>ok = client.write_holding_typed_safe(\n    addr=702,\n    value=-12345678,\n    dtype=ModbusDataType.INT32,\n    endian=Endian.BE\n)\n\nif ok:\n    print(\"INT32 escrito com sucesso\")\nelse:\n    print(\"Falha na escrita do INT32\")\n</code></pre>"},{"location":"examples/write_integers32bits/#observacao-sobre-endianness","title":"Observa\u00e7\u00e3o sobre endianness","text":"<p>Para valores de 32 bits, o endianness \u00e9 cr\u00edtico.</p> <p>Se o dispositivo utilizar word swap ou byte swap, teste:</p> <ul> <li><code>Endian.LE</code></li> <li><code>Endian.BE_SWAP</code></li> <li><code>Endian.LE_SWAP</code></li> </ul> <p>A biblioteca n\u00e3o tenta inferir automaticamente o endianness correto.</p>"},{"location":"examples/write_integers32bits/#diferenca-entre-int32-e-uint32","title":"Diferen\u00e7a entre INT32 e UINT32","text":"<ul> <li><code>UINT32</code> aceita valores de 0 a 4.294.967.295</li> <li><code>INT32</code> aceita valores de -2.147.483.648 a 2.147.483.647</li> <li>Ambos ocupam 2 registradores Modbus</li> <li>A biblioteca valida automaticamente o range</li> </ul>"},{"location":"examples/write_integers32bits/#comportamento-dos-metodos","title":"Comportamento dos m\u00e9todos","text":"<p>Os m\u00e9todos de escrita tipada:</p> <ul> <li>Retornam <code>True</code> em caso de sucesso</li> <li>Retornam <code>False</code> em caso de falha</li> <li>Validam tipo e faixa de valores</li> <li>Realizam reconex\u00e3o autom\u00e1tica se necess\u00e1rio</li> <li>Aplicam backoff exponencial</li> <li>Registram logs detalhados</li> </ul>"},{"location":"examples/write_integers32bits/#observacoes-importantes","title":"Observa\u00e7\u00f5es importantes","text":"<ul> <li>O endere\u00e7amento \u00e9 zero-based</li> <li>Utilize sempre o endianness correto</li> <li>N\u00e3o escreva valores fora do range permitido</li> <li>Sempre verifique o retorno do m\u00e9todo</li> </ul>"},{"location":"examples/write_integers32bits/#encerrando-a-conexao","title":"Encerrando a conex\u00e3o","text":"<p>Ap\u00f3s finalizar as escritas, a conex\u00e3o pode ser encerrada explicitamente:</p> <pre><code>client.close()\n</code></pre>"},{"location":"examples/write_integers64bits/","title":"Escrita de Inteiros de 64 Bits","text":""},{"location":"examples/write_integers64bits/#exemplo-escrita-de-inteiros-de-64-bits","title":"Exemplo \u2013 Escrita de Inteiros de 64 Bits","text":"<p>Este exemplo demonstra como realizar a escrita de valores inteiros de 64 bits utilizando a biblioteca pyModbusTCPtools, contemplando valores sem sinal (UINT64) e valores com sinal (INT64).</p> <p>Valores de 64 bits ocupam quatro registradores Modbus consecutivos, exigindo aten\u00e7\u00e3o especial ao endianness configurado no dispositivo.</p>"},{"location":"examples/write_integers64bits/#cenario-tipico","title":"Cen\u00e1rio t\u00edpico","text":"<ul> <li>Escrita de contadores de grande capacidade</li> <li>Escrita de acumuladores de energia ou produ\u00e7\u00e3o</li> <li>Configura\u00e7\u00e3o de par\u00e2metros num\u00e9ricos extensos</li> <li>Ajuste de vari\u00e1veis internas de alta resolu\u00e7\u00e3o em CLPs</li> </ul> <p>Neste exemplo, ser\u00e1 realizada a escrita em Holding Registers a partir do endere\u00e7o 800.</p>"},{"location":"examples/write_integers64bits/#importacoes","title":"Importa\u00e7\u00f5es","text":"<pre><code>from pyModbusTCPtools import (\n    ModbusTCPResiliente,\n    ModbusDataType,\n    Endian\n)\n</code></pre>"},{"location":"examples/write_integers64bits/#criacao-do-cliente","title":"Cria\u00e7\u00e3o do cliente","text":"<pre><code>client = ModbusTCPResiliente(\n    host=\"192.168.0.10\",\n    unit_id=1,\n    timeout=3.0,\n    console=True\n)\n</code></pre>"},{"location":"examples/write_integers64bits/#escrita-de-inteiro-de-64-bits-sem-sinal-uint64","title":"Escrita de inteiro de 64 bits sem sinal (UINT64)","text":"<pre><code>ok = client.write_holding_typed_safe(\n    addr=800,\n    value=123456789012345,\n    dtype=ModbusDataType.UINT64,\n    endian=Endian.BE\n)\n\nif ok:\n    print(\"UINT64 escrito com sucesso\")\nelse:\n    print(\"Falha na escrita do UINT64\")\n</code></pre>"},{"location":"examples/write_integers64bits/#escrita-de-inteiro-de-64-bits-com-sinal-int64","title":"Escrita de inteiro de 64 bits com sinal (INT64)","text":"<pre><code>ok = client.write_holding_typed_safe(\n    addr=804,\n    value=-123456789012345,\n    dtype=ModbusDataType.INT64,\n    endian=Endian.BE\n)\n\nif ok:\n    print(\"INT64 escrito com sucesso\")\nelse:\n    print(\"Falha na escrita do INT64\")\n</code></pre>"},{"location":"examples/write_integers64bits/#observacao-sobre-endianness","title":"Observa\u00e7\u00e3o sobre endianness","text":"<p>Para valores de 64 bits, a configura\u00e7\u00e3o correta de endianness \u00e9 cr\u00edtica.</p> <p>Caso o valor escrito n\u00e3o seja interpretado corretamente pelo dispositivo, teste:</p> <ul> <li><code>Endian.LE</code></li> <li><code>Endian.BE_SWAP</code></li> <li><code>Endian.LE_SWAP</code></li> </ul> <p>A biblioteca n\u00e3o tenta inferir automaticamente o endianness correto.</p>"},{"location":"examples/write_integers64bits/#diferenca-entre-int64-e-uint64","title":"Diferen\u00e7a entre INT64 e UINT64","text":"<ul> <li><code>UINT64</code> aceita valores de 0 a 18.446.744.073.709.551.615</li> <li><code>INT64</code> aceita valores de -9.223.372.036.854.775.808 a 9.223.372.036.854.775.807</li> <li>Ambos ocupam 4 registradores Modbus</li> <li>A biblioteca valida automaticamente o range antes da escrita</li> </ul>"},{"location":"examples/write_integers64bits/#comportamento-dos-metodos","title":"Comportamento dos m\u00e9todos","text":"<p>Os m\u00e9todos de escrita tipada:</p> <ul> <li>Retornam <code>True</code> em caso de sucesso</li> <li>Retornam <code>False</code> em caso de falha</li> <li>Validam tipo, tamanho e faixa de valores</li> <li>Realizam reconex\u00e3o autom\u00e1tica se necess\u00e1rio</li> <li>Aplicam backoff exponencial</li> <li>Registram logs detalhados</li> </ul>"},{"location":"examples/write_integers64bits/#observacoes-importantes","title":"Observa\u00e7\u00f5es importantes","text":"<ul> <li>O endere\u00e7amento \u00e9 zero-based</li> <li>Utilize sempre o endianness correto</li> <li>Valores fora do range resultam em erro de convers\u00e3o</li> <li>Sempre verifique o retorno do m\u00e9todo</li> </ul>"},{"location":"examples/write_integers64bits/#encerrando-a-conexao","title":"Encerrando a conex\u00e3o","text":"<p>Ap\u00f3s finalizar as escritas, a conex\u00e3o pode ser encerrada explicitamente:</p> <pre><code>client.close()\n</code></pre>"},{"location":"examples/write_integers64bits/#proximo-passo","title":"Pr\u00f3ximo passo","text":"<p>Ap\u00f3s compreender a escrita de inteiros de 64 bits, avance para os exemplos de escrita de valores em ponto flutuante, iniciando com FLOAT32.</p>"}]}